<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Forca Multijogador</title>
    <style>
      @font-face {
        font-family: "Gopher";
        src: url("Gopher-Light.ttf") format("truetype");
        font-weight: 300;
        font-style: normal;
        font-display: swap;
      }

      /* Fonte para o texto de eliminação (arquivo Graffiti-City.otf) */
      @font-face {
        font-family: "GraffityCity";
        src: url("Graffiti-City.otf") format("opentype");
        font-weight: 400;
        font-style: normal;
        font-display: swap;
      }

      :root {
        color-scheme: dark;
        --bg: #010307;
        --panel: #11162b;
        --panel-alt: #0f1428;
        --border: rgba(255, 255, 255, 0.08);
        --accent: #6ef2a9;
        --vivid: #2dd7ff;
        --btn-solid-text: #0b0f1b;
        --theme-border: rgba(45, 215, 255, 0.8);
        --theme-bg-weak: rgba(45, 215, 255, 0.16);
        --text: #f7fbff;
        --muted: rgba(255, 255, 255, 0.65);
        --info: #6e90ff;
        --error: #ff8a8a;
        --app-zoom: 1;
        font-family: "Gopher", "Inter", "Segoe UI", system-ui, sans-serif;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        background: radial-gradient(circle at 20% 20%, rgba(85, 160, 255, 0.05), transparent 45%),
          linear-gradient(135deg, #01020b, var(--bg) 90%);
        color: var(--text);
      }

      .app-shell {
        width: min(1100px, 100%);
        margin: 0 auto;
        padding: 2.5rem 1.5rem 3rem;
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
        transform: scale(var(--app-zoom));
        transform-origin: top center;
        width: calc(100% / var(--app-zoom));
      }

      .app-header {
        background: var(--panel);
        border-radius: 24px;
        padding: 1.5rem 16rem 1.5rem 1.5rem;
        border: 1px solid rgba(255, 255, 255, 0.08);
        position: relative;
        display: flex;
        flex-direction: column;
        gap: 0.65rem;
        box-shadow: 0 20px 35px rgba(3, 4, 10, 0.7);
      }

      .app-header.is-hidden {
        display: none;
      }

      .language-picker {
        display: none;
      }

      .bed-dropdown {
        position: relative;
        min-width: 180px;
      }

      .bed-trigger {
        position: relative;
        width: 100%;
        display: inline-flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.5rem;
        background: linear-gradient(135deg, rgba(12, 18, 32, 0.9), rgba(18, 28, 48, 0.9));
        color: var(--text);
        border: 1px solid var(--theme-border);
        border-radius: 14px;
        padding: 0.5rem 0.85rem;
        font: inherit;
        cursor: pointer;
        transition: border-color 0.2s ease, background 0.2s ease, box-shadow 0.18s ease, transform 0.18s ease;
      }

      .bed-arrow {
        position: absolute;
        right: 16px;
        top: 50%;
        transform: translateY(-50%);
        color: var(--text);
        opacity: 0.8;
        pointer-events: none;
        transition: opacity 0.15s ease, transform 0.15s ease;
        animation: bedArrowFloat 1.6s ease-in-out infinite;
      }

      .bed-dropdown.is-open .bed-arrow {
        opacity: 0;
        transform: translateY(-50%) translateY(-2px);
        animation: none;
      }

      @keyframes bedArrowFloat {
        0% { transform: translateY(-52%); }
        50% { transform: translateY(-46%); }
        100% { transform: translateY(-52%); }
      }

      .bed-trigger:hover {
        border-color: var(--theme-border);
        background: linear-gradient(135deg, rgba(20, 38, 64, 0.95), rgba(32, 54, 86, 0.95));
        box-shadow: 0 12px 24px rgba(0, 0, 0, 0.35), 0 0 0 1px var(--theme-bg-weak);
        transform: translateY(-1px);
      }

      .bed-trigger:focus-visible {
        outline: 2px solid var(--accent);
        outline-offset: 2px;
      }

      .bed-menu {
        position: absolute;
        top: calc(100% + 6px);
        left: 0;
        right: 0;
        background: #0b1224;
        border: 1px solid rgba(255, 255, 255, 0.14);
        border-radius: 16px;
        box-shadow: 0 16px 32px rgba(0, 0, 0, 0.45), 0 0 0 1px rgba(45, 215, 255, 0.1);
        padding: 0.35rem;
        display: none;
        flex-direction: column;
        gap: 0.25rem;
        z-index: 8;
      }

      .bed-dropdown.is-open .bed-menu {
        display: flex;
      }

      .bed-option {
        width: 100%;
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
        background: transparent;
        border: none;
        color: var(--text);
        padding: 0.5rem 0.65rem;
        border-radius: 12px;
        text-align: left;
        cursor: pointer;
        font: inherit;
        transition: background 0.15s ease, transform 0.15s ease, color 0.15s ease;
      }

      .bed-option:hover {
        background: var(--theme-bg-weak);
        color: #e7fbff;
        transform: translateX(2px);
      }

      .bed-option.is-active {
        background: var(--theme-bg-weak);
        border: 1px solid var(--theme-border);
      }

      .mode-row {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        flex-wrap: wrap;
      }

      .mode-label {
        font-size: 0.8rem;
        letter-spacing: 0.08rem;
        text-transform: uppercase;
        color: rgba(255, 255, 255, 0.65);
      }

      .mode-button {
        border-radius: 999px;
        border: 1px solid transparent;
        background: var(--theme-bg-weak);
        color: var(--text);
        padding: 0.45rem 1rem;
        font: inherit;
        letter-spacing: 0.04rem;
        cursor: pointer;
        transition: background 0.2s ease, border 0.2s ease;
      }

      .mode-button:hover:not(:disabled) {
        transform: translateY(-1px) scale(1.03);
        border-color: transparent;
        background: var(--theme-bg-weak);
      }

      .mode-button.is-active {
        background: var(--theme-bg-weak);
        border-color: var(--theme-border);
        color: var(--text);
      }

      .mode-button:disabled {
        opacity: 0.45;
        cursor: not-allowed;
        transform: none;
      }

      .ghost-btn.tiny {
        padding: 0.4rem 0.9rem;
        font-size: 0.9rem;
      }

      .ghost-btn {
        border: 1px solid var(--theme-border);
        background: rgba(255, 255, 255, 0.02);
        color: var(--text);
        transition: border-color 0.18s ease, background 0.18s ease, transform 0.18s ease, box-shadow 0.18s ease;
      }

      .ghost-btn:hover {
        border-color: var(--theme-border);
        background: var(--theme-bg-weak);
        transform: translateY(-1px);
        box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
      }

      #change-word-btn,
      #menu-cancel-btn {
        border-color: var(--theme-border);
        background: rgba(255, 255, 255, 0.02);
        color: var(--text);
      }

      #change-word-btn:hover,
      #menu-cancel-btn:hover {
        border-color: var(--theme-border);
        background: var(--theme-bg-weak);
      }

      #reviews-btn:hover {
        border-color: var(--theme-border);
        box-shadow: 0 10px 22px rgba(0, 0, 0, 0.35);
        transform: translateY(-1px);
        background: var(--theme-bg-weak);
      }

      #reviews-btn {
        border-color: var(--theme-border);
        box-shadow: 0 0 0 1px var(--theme-border);
        margin-left: auto;
        margin-top: 10px;
        margin-right: -60px;
      }

      #reviews-btn.is-active {
        border-color: var(--theme-border);
        background: var(--theme-bg-weak);
        color: var(--text);
        box-shadow: 0 0 0 1px var(--theme-bg-weak), 0 10px 22px rgba(0, 0, 0, 0.28);
      }

      #reviews-close:hover {
        border-color: rgba(42, 168, 216, 0.85);
        color: #e7fbff;
        transform: translateY(-1px);
      }

      #review-submit:hover {
        box-shadow: 0 12px 24px rgba(0, 0, 0, 0.35);
        transform: translateY(-1px);
        filter: brightness(1.05);
      }

      .header-actions {
        display: flex;
        gap: 0.75rem;
        align-items: center;
        flex-wrap: wrap;
        position: relative;
      }

      .header-divider {
        width: 1px;
        height: 120px;
        background: rgba(255, 255, 255, 0.2);
        flex: 0 0 auto;
        align-self: flex-start;
        margin-top: -50px;
      }

      .info-wrapper {
        position: absolute;
        right: -245px;
        bottom: 4px;
        display: inline-flex;
        align-items: flex-end;
        justify-content: flex-end;
        pointer-events: none;
      }

      .info-button {
        pointer-events: auto;
        width: 42px;
        height: 42px;
        border: none;
        border-radius: 10px;
        background: transparent;
        color: var(--text);
        font-size: 1.4rem;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        padding: 2px 4px;
        box-shadow: none;
        transition: transform 0.18s ease, box-shadow 0.18s ease, border-color 0.18s ease, color 0.18s ease;
      }

      .info-button:hover {
        transform: translateY(-2px) scale(1.02);
        color: var(--vivid);
      }

      .info-popover {
        position: absolute;
        top: calc(100% + 12px);
        right: 0;
        max-width: 640px;
        min-width: 480px;
        width: 70vw;
        background: rgba(10, 14, 28, 0.92);
        border: 1px solid rgba(255, 255, 255, 0.12);
        border-radius: 14px;
        padding: 0.9rem 1.1rem;
        color: var(--text);
        font-size: 0.95rem;
        line-height: 1.5;
        box-shadow: 0 16px 32px rgba(0, 0, 0, 0.45);
        z-index: 50;
        opacity: 0;
        visibility: hidden;
        transform: translateY(6px);
        pointer-events: none;
        transition: opacity 0.2s ease, transform 0.2s ease, visibility 0.2s ease;
      }

      .info-wrapper:hover .info-popover,
      .info-wrapper:focus-within .info-popover {
        opacity: 1;
        transform: translateY(0);
        pointer-events: auto;
        visibility: visible;
      }

      .color-switcher {
        position: absolute;
        top: 14px;
        right: -190px;
        display: inline-flex;
        align-items: center;
        gap: 0.1rem;
        pointer-events: none;
      }

      .color-switcher__btn {
        pointer-events: auto;
        width: 32px;
        height: 32px;
        border-radius: 10px;
        border: none;
        background: transparent;
        color: var(--text);
        display: inline-flex;
        align-items: center;
        justify-content: center;
        transition: transform 0.16s ease, border-color 0.16s ease, background 0.16s ease, color 0.16s ease;
      }

      .color-switcher__btn:hover {
        transform: translateY(-1px);
        color: #e7fbff;
        background: var(--theme-bg-weak);
      }

      .color-switcher__circle-wrap {
        pointer-events: auto;
        display: inline-flex;
        flex-direction: column;
        align-items: center;
        gap: 0.2rem;
        width: 50px;
        flex: 0 0 50px;
        overflow: visible;
      }

      .color-switcher__circle {
        width: 36px;
        height: 36px;
        border-radius: 50%;
        border: 2px solid rgba(255, 255, 255, 0.2);
        background: var(--vivid);
        box-shadow: 0 12px 24px rgba(0, 0, 0, 0.35);
        transition: transform 0.28s ease, opacity 0.28s ease;
      }

      .color-switcher__circle.is-exit-left {
        opacity: 0;
        transform: translateX(-28px) scale(0.78);
      }

      .color-switcher__circle.is-exit-right {
        opacity: 0;
        transform: translateX(28px) scale(0.78);
      }

      .color-switcher__circle.is-enter-left {
        opacity: 0;
        transform: translateX(-28px) scale(0.78);
      }

      .color-switcher__circle.is-enter-right {
        opacity: 0;
        transform: translateX(28px) scale(0.78);
      }

      .color-switcher__label {
        font-size: 0.9rem;
        color: var(--text);
        text-transform: capitalize;
        text-align: center;
        width: 100%;
        white-space: nowrap;
        overflow: visible;
        display: inline-flex;
        justify-content: center;
      }

      @keyframes chest-open {
        0% { transform: scale(0.92) translateY(8px); opacity: 0; }
        60% { transform: scale(1.03) translateY(-4px); opacity: 1; }
        100% { transform: scale(1) translateY(0); opacity: 1; }
      }

      @keyframes chest-close {
        0% { transform: scale(1) translateY(0); opacity: 1; }
        100% { transform: scale(0.9) translateY(12px); opacity: 0; }
      }

      .panel-animate-open {
        animation: chest-open 0.28s ease forwards;
      }

      .panel-animate-close {
        animation: chest-close 0.18s ease forwards;
      }

      .bed-legs-control {
        color: var(--text);
        font-size: 0.8rem;
        letter-spacing: 0.04rem;
        display: flex;
        align-items: center;
        gap: 0.6rem;
        flex-wrap: wrap;
      }

      .bed-legs-menu {
        display: flex;
        gap: 0.4rem;
        flex-wrap: wrap;
      }

      .bed-legs-option {
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.25);
        background: transparent;
        color: var(--text);
        padding: 0.35rem 0.8rem;
        font: inherit;
        cursor: pointer;
        transition: border-color 0.2s ease, background 0.2s ease, color 0.2s ease;
      }

      .bed-legs-option.is-active,
      .bed-legs-option:hover {
        border-color: rgba(125, 251, 255, 0.8);
        background: rgba(125, 251, 255, 0.1);
      }

      button {
        border: none;
        font: inherit;
        cursor: pointer;
        transition: transform 0.2s ease, opacity 0.2s ease, box-shadow 0.2s ease;
      }

      body.hide-buttons button:not(.letter-key):not(#restart-btn):not(#restart-confirm-yes):not(#restart-confirm-no) {
        background: transparent;
        border-color: transparent;
        color: transparent;
        box-shadow: none;
        transition: none;
      }

      body.controls-locked button:not(#restart-btn):not(#restart-confirm-yes):not(#restart-confirm-no):not(.letter-key),
      body.controls-locked .player-selector-button {
        visibility: hidden;
        pointer-events: none;
      }
      body.controls-locked #restart-btn {
        visibility: visible;
        pointer-events: auto;
      }

      body.controls-locked #restart-confirm,
      body.controls-locked #restart-confirm button,
      body.controls-locked #restart-confirm-yes,
      body.controls-locked #restart-confirm-no {
        visibility: visible;
        pointer-events: auto;
      }

      body.controls-locked .letter-key {
        visibility: visible;
        pointer-events: auto;
      }

      button:focus-visible {
        outline: 2px solid var(--accent);
        outline-offset: 3px;
      }

      .volume-control {
        position: absolute;
        top: 10px;
        right: 10px;
        display: flex;
        flex-direction: column;
        align-items: flex-start;
        gap: 0.35rem;
        background: rgba(255, 255, 255, 0.06);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 16px;
        padding: 0.5rem 0.65rem 0.5rem 0.8rem;
        z-index: 3;
        pointer-events: auto;
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.35);
        transform: translateY(-6px);
      }

      .zoom-panel {
        position: absolute;
        top: 10px;
        right: 340px;
        display: flex;
        align-items: center;
        gap: 0.4rem;
        background: rgba(255, 255, 255, 0.06);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 14px;
        padding: 0.45rem 0.55rem;
        z-index: 3;
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.35);
      }

      .volume-control.is-hidden {
        display: none;
      }

      .volume-row {
        display: flex;
        align-items: center;
        gap: 0.4rem;
        flex: 0 0 auto;
        white-space: nowrap;
      }

      .volume-slider-wrap {
        display: flex;
        flex-direction: column;
        align-items: flex-end;
        gap: 0.15rem;
        min-width: 110px;
      }

      .volume-control label {
        font-size: 0.8rem;
        letter-spacing: 0.02rem;
        color: var(--muted);
        min-width: 110px;
        white-space: nowrap;
      }

      .volume-control input[type="range"] {
        -webkit-appearance: none;
        appearance: none;
        width: 120px;
        height: 8px;
        background: linear-gradient(90deg, rgba(255, 255, 255, 0.06), rgba(255, 255, 255, 0.02));
        border: 1px solid var(--theme-bg-weak);
        border-radius: 999px;
        outline: none;
        box-shadow: inset 0 2px 6px rgba(0, 0, 0, 0.45);
      }

      .volume-control input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 14px;
        height: 14px;
        border-radius: 50%;
        background: radial-gradient(circle at 30% 30%, #c6fbff, var(--vivid) 60%, var(--accent) 100%);
        box-shadow: 0 0 10px var(--theme-border), 0 0 0 2px var(--theme-bg-weak);
        border: 1px solid rgba(255, 255, 255, 0.35);
        cursor: pointer;
        transition: box-shadow 0.2s ease, transform 0.2s ease;
      }

      .volume-control input[type="range"]::-moz-range-thumb {
        width: 14px;
        height: 14px;
        border-radius: 50%;
        background: radial-gradient(circle at 30% 30%, #c6fbff, var(--vivid) 60%, var(--accent) 100%);
        box-shadow: 0 0 10px var(--theme-border), 0 0 0 2px var(--theme-bg-weak);
        border: 1px solid rgba(255, 255, 255, 0.35);
        cursor: pointer;
        transition: box-shadow 0.2s ease, transform 0.2s ease;
      }

      .volume-control input[type="range"]:hover::-webkit-slider-thumb,
      .volume-control input[type="range"]:focus-visible::-webkit-slider-thumb {
        box-shadow: 0 0 14px var(--theme-border), 0 0 0 3px var(--theme-bg-weak);
        transform: translateY(-1px);
      }
      .volume-control input[type="range"]:hover::-moz-range-thumb,
      .volume-control input[type="range"]:focus-visible::-moz-range-thumb {
        box-shadow: 0 0 14px var(--theme-border), 0 0 0 3px var(--theme-bg-weak);
        transform: translateY(-1px);
      }

      .volume-value {
        font-size: 0.85rem;
        font-family: "Gopher", "Inter", "Segoe UI", system-ui, sans-serif;
        color: var(--text);
        min-width: 34px;
        text-align: right;
        background: transparent;
        border: none;
        border-bottom: 1px solid transparent;
        padding: 0 0.15rem;
        outline: none;
        transition: border-color 0.18s ease, color 0.18s ease;
        cursor: text;
        width: 36px;
      }

      .volume-value:hover,
      .volume-value:focus-visible {
        border-bottom-color: rgba(71, 232, 255, 0.6);
        color: #e7fbff;
      }

      .zoom-control {
        display: flex;
        align-items: center;
        gap: 0.35rem;
        white-space: nowrap;
      }

      .zoom-btn {
        width: 34px;
        height: 34px;
        border-radius: 10px;
        border: 1px solid var(--theme-border);
        background: rgba(255, 255, 255, 0.04);
        color: var(--text);
        display: inline-flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: transform 0.16s ease, box-shadow 0.16s ease, border-color 0.16s ease, background 0.16s ease;
      }

      .zoom-btn:hover {
        border-color: var(--theme-border);
        background: var(--theme-bg-weak);
        box-shadow: 0 8px 18px rgba(0, 0, 0, 0.32);
        transform: translateY(-1px);
      }

      .zoom-value {
        font-size: 0.9rem;
        color: var(--text);
        min-width: 44px;
        text-align: right;
      }
      .solid-btn {
        padding: 0.75rem 1.5rem;
        border-radius: 999px;
        background: linear-gradient(135deg, var(--accent), var(--vivid));
        border: 1px solid var(--theme-border);
        color: var(--btn-solid-text, #0b0f1b);
        font-weight: 600;
        letter-spacing: 0.02rem;
        transition: transform 0.18s ease, box-shadow 0.18s ease, opacity 0.18s ease, border-color 0.18s ease;
      }

      #add-player-btn:hover,
      #start-game-btn:hover {
        transform: translateY(-1px) scale(1.03);
        box-shadow: 0 12px 26px rgba(0, 0, 0, 0.3);
      }

      .ghost-btn {
        padding: 0.65rem 1.2rem;
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.3);
        background: transparent;
        color: var(--text);
        transition: transform 0.18s ease, box-shadow 0.18s ease, opacity 0.18s ease;
      }

      .letter-result {
        margin: 0;
        color: rgba(255, 255, 255, 0.7);
        font-size: 0.9rem;
        display: none;
        opacity: 0;
        transition: opacity 0.2s ease;
      }

      .letter-result[data-tone="error"] {
        color: var(--error);
      }

      .letter-result[data-tone="success"] {
        color: var(--accent);
      }

      .letter-result.is-visible {
        display: block;
        opacity: 1;
      }

      .players-shell {
        background: var(--panel);
        border-radius: 28px;
        border: 1px solid var(--border);
        padding: 1.3rem;
        box-shadow: 0 18px 35px rgba(3, 4, 10, 0.7);
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }

      .player-toolbar {
        color: var(--muted);
        font-size: 0.9rem;
      }

      .player-stage {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
        gap: 1rem;
      }

      .empty-state {
        padding: 1rem;
        border-radius: 14px;
        border: 1px dashed rgba(255, 255, 255, 0.2);
        text-align: center;
        color: rgba(255, 255, 255, 0.5);
      }

      .player-card {
        background: linear-gradient(180deg, rgba(255, 255, 255, 0.02), rgba(255, 255, 255, 0.04));
        border-radius: 18px;
        border: 1px solid var(--theme-border);
        padding: 1rem;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 0.65rem;
        position: relative;
        min-height: 200px;
        overflow: hidden;
      }

      .player-card::after {
        content: "";
        position: absolute;
        inset: 0;
        background: rgba(2, 3, 8, 0.62);
        backdrop-filter: blur(2px);
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.35s ease;
        z-index: 2;
      }

      .player-card.is-starting {
        border-color: var(--theme-border);
        box-shadow: 0 0 0 2px var(--theme-bg-weak);
      }

      .player-card--removable .player-card__action {
        opacity: 0;
        pointer-events: none;
      }

      .player-card--removable:hover .player-card__action,
      .player-card.is-confirming .player-card__action {
        opacity: 1;
        pointer-events: auto;
        transform: translateY(0);
      }

      .player-card__remove-panel {
        position: absolute;
        top: 14px;
        right: 12px;
        display: flex;
        flex-direction: column;
        align-items: flex-end;
        gap: 0.35rem;
        z-index: 4;
      }

      .player-card__actions {
        display: flex;
        gap: 0.35rem;
      }

      .player-card__action {
        width: 36px;
        height: 36px;
        border-radius: 50%;
        border: 1px solid var(--theme-border);
        background: rgba(255, 255, 255, 0.02);
        color: var(--text);
        font-size: 1.2rem;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: opacity 0.2s ease, transform 0.2s ease, border-color 0.2s, box-shadow 0.2s ease;
        transform: translateY(-4px);
      }

      .player-card__edit {
        font-size: 1.05rem;
      }

      .player-card.is-confirming .player-card__confirm {
        display: flex;
      }

      .player-card__confirm {
        display: none;
        flex-direction: column;
        gap: 0.75rem;
        position: absolute;
        top: 46px;
        right: -12px;
        width: 210px;
        padding: 0.9rem;
        border-radius: 16px;
        border: 1px solid var(--border);
        background: var(--panel-alt);
        box-shadow: 0 18px 30px rgba(0, 0, 0, 0.45);
        color: var(--text);
        font-size: 0.9rem;
        text-align: center;
      }

      .player-card__confirm-actions {
        display: flex;
        gap: 0.5rem;
      }

      .player-card__confirm-actions button {
        flex: 1;
        font-size: 0.85rem;
        padding: 0.4rem 0.55rem;
        transition: transform 0.15s ease, box-shadow 0.2s ease, border-color 0.2s ease;
      }

      .player-card__confirm-yes {
        background: linear-gradient(135deg, #6ef2a9, #2dd7ff);
        color: #0b0f1b;
      }

      .player-card__confirm-no {
        border-color: rgba(255, 255, 255, 0.5);
        color: var(--error);
      }

      .player-card__confirm-actions button:hover {
        transform: translateY(-1px);
        box-shadow: 0 6px 14px rgba(0, 0, 0, 0.2);
      }

      .finish-close-btn:hover {
        transform: translateY(-1px);
        box-shadow: 0 6px 14px rgba(0, 0, 0, 0.2);
      }

      .player-card__action:hover {
        border-color: var(--theme-border);
        box-shadow: 0 0 0 2px var(--theme-bg-weak), 0 8px 18px rgba(0, 0, 0, 0.3);
      }

      .player-card__action:focus-visible {
        outline: 2px solid var(--accent);
        outline-offset: 2px;
        border-color: var(--theme-border);
      }

      .player-placeholder {
        width: 100%;
        display: flex;
        justify-content: center;
      }

      .player-bed {
        position: relative;
        width: min(360px, 100%);
        display: flex;
        justify-content: center;
        align-items: flex-start;
      }

      .player-bed__art {
        position: relative;
        z-index: 2;
        width: 100%;
        height: auto;
        display: block;
      }

      .player-bed__art.is-bluetiara {
        transform: none;
      }

      .zz-callout {
        position: absolute;
        top: -18px;
        left: 22%;
        font-size: 1.2rem;
        font-weight: 700;
        letter-spacing: 0.2rem;
        color: rgba(255, 255, 255, 0.9);
        text-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
        animation: floatZz 3s ease-in-out infinite;
        opacity: 0.9;
        z-index: 3;
        text-transform: uppercase;
      }

      .zz-callout__lower {
        display: block;
        margin-top: 0.25rem;
        font-size: 0.9em;
        text-transform: lowercase;
      }

      .player-bed__legs {
        position: absolute;
        bottom: 21px;
        left: 20%;
        right: 20%;
        display: flex;
        justify-content: center;
        gap: 24px;
        z-index: 1;
      }

      .player-bed__leg {
        width: 12px;
        height: 0.72cm;
        border-radius: 4px;
        background: #39464e;
        box-shadow: inset 0 10px 10px rgba(255, 255, 255, 0.12);
        transition: opacity 0.2s ease, filter 0.2s ease;
      }

      .player-bed__leg.is-gone {
        opacity: 0.4;
        filter: brightness(0.75);
      }



      @keyframes floatZz {
        0% { transform: translate(-50%, -4px); opacity: 0.3; }
        50% { transform: translate(-50%, -8px); opacity: 1; }
        100% { transform: translate(-50%, -4px); opacity: 0.3; }
      }
      
      .player-letters {
        font-size: 0.85rem;
        color: rgba(255, 255, 255, 0.65);
        letter-spacing: 0.08rem;
        text-transform: uppercase;
        width: 100%;
        text-align: center;
        margin-bottom: 0.35rem;
      }

      .player-card.is-active {
        border-color: var(--accent);
        box-shadow: 0 0 0 2px rgba(125, 251, 255, 0.35);
      }

      .player-card.is-eliminated::after {
        opacity: 1;
      }

      .player-elim-gif {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.35s ease;
        background: url("lose-overlay.gif") center center / 82% no-repeat;
        filter: drop-shadow(0 10px 25px rgba(0, 0, 0, 0.6));
        z-index: 3;
        flex-direction: column;
        gap: 0.6rem;
      }

      .player-card.is-eliminated .player-elim-gif {
        opacity: 1;
        animation: elimFade 0.45s ease forwards;
      }

      .player-card.is-eliminated .player-elim-gif .elim-text {
        opacity: 1;
      }

      .player-elim-gif .elim-text {
        color: #f7fbff;
        font-family: "GraffityCity", "Gopher", system-ui, sans-serif;
        font-weight: 800;
        font-size: 2.6rem;
        letter-spacing: 0.24rem;
        text-shadow: 0 8px 18px rgba(0, 0, 0, 0.8);
        background: rgba(0, 0, 0, 0.35);
        padding: 0.45rem 0.8rem;
        border-radius: 12px;
        border: none;
        text-align: center;
        opacity: 0;
        transition: opacity 0.35s ease;
      }

      @keyframes elimFade {
        from {
          opacity: 0;
          transform: scale(0.96);
        }
        to {
          opacity: 1;
          transform: scale(1);
        }
      }

      .player-rope {
        width: 4px;
        height: 62px;
        position: relative;
        background: linear-gradient(180deg, var(--border), transparent);
        animation: sway 4s ease-in-out infinite;
      }

      .player-rope .rope-loop {
        position: absolute;
        width: 12px;
        height: 12px;
        border-radius: 50%;
        border: 2px solid var(--border);
        top: 55px;
        left: 50%;
        transform: translateX(-50%);
      }

      .rope-line {
        width: 4px;
        height: 45px;
        background: var(--border);
        position: absolute;
        inset: 0 auto auto 50%;
        transform: translateX(-50%);
      }

      .player-hangman {
        position: relative;
        width: 76px;
        height: 132px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: flex-start;
        transform: scale(0.92);
        transform-origin: center;
      }

      .player-torso {
        width: 34px;
        height: 58px;
        border-radius: 18px;
        position: absolute;
        top: 48px;
        left: 50%;
        transform: translateX(-50%);
        background: linear-gradient(180deg, rgba(255, 255, 255, 0.05), rgba(255, 255, 255, 0.08));
      }

      .player-hangman.outfit-bow .player-torso {
        background: linear-gradient(180deg, #ff9cd8, #ff73c2);
      }

      .player-hangman.outfit-bow .player-torso::after {
        content: "";
        position: absolute;
        left: 50%;
        bottom: 10px;
        transform: translateX(-50%);
        width: 60px;
        height: 8px;
        background: #fff;
        border-radius: 6px;
        box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.5);
      }

      .player-hangman.outfit-cap .player-torso {
        background: linear-gradient(180deg, #fff, #d8e2ff 70%);
      }

      .player-hangman.outfit-cap .player-torso::after {
        content: "";
        position: absolute;
        width: 32px;
        height: 16px;
        bottom: 8px;
        left: 50%;
        transform: translateX(-50%);
        background: linear-gradient(180deg, #6b93d6, #3d6fb5);
        border-radius: 10px;
        box-shadow: inset 0 2px 0 rgba(255, 255, 255, 0.6);
      }

      .player-hangman.outfit-cap .player-torso::before {
        content: "";
        position: absolute;
        width: 46px;
        height: 18px;
        bottom: 30px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 88, 179, 0.35);
        border-radius: 8px;
        box-shadow: inset -12px 0 0 #1d4f86, inset 12px 0 0 #1d4f86;
      }

      .hangman-part {
        position: absolute;
        background: rgba(255, 255, 255, 0.35);
        border-radius: 4px;
        opacity: 0;
        transition: opacity 0.2s ease, background 0.2s ease;
      }

      .hangman-part.is-visible {
        opacity: 1;
        background: var(--accent);
      }

      .part-body {
        width: 6px;
        height: 60px;
        top: 50px;
        left: 50%;
        transform: translateX(-50%);
      }

      .part-arm-left,
      .part-arm-right,
      .part-leg-left,
      .part-leg-right {
        width: 32px;
        height: 6px;
        top: 94px;
        transform-origin: center;
      }

      .part-arm-left {
        left: 6px;
        transform: rotate(-35deg);
      }

      .part-arm-right {
        right: 6px;
        transform: rotate(35deg);
      }

      .part-leg-left {
        top: 118px;
        left: 22px;
        transform: rotate(55deg);
      }

      .part-leg-right {
        top: 118px;
        right: 22px;
        transform: rotate(-55deg);
      }

      .player-head {
        width: 48px;
        height: 48px;
        border-radius: 50%;
        border: 2px solid rgba(255, 255, 255, 0.6);
        background: rgba(255, 255, 255, 0.04);
        position: relative;
        opacity: 0.4;
        transition: border 0.2s ease, background 0.2s ease, opacity 0.2s ease;
      }

      .player-head.is-visible {
        background: rgba(125, 251, 255, 0.12);
        border-color: var(--accent);
        opacity: 1;
      }

      .player-head.head-bow::after {
        content: "";
        position: absolute;
        width: 26px;
        height: 10px;
        top: -10px;
        left: 50%;
        transform: translateX(-50%);
        background: linear-gradient(90deg, rgba(255, 132, 203, 0.9), rgba(255, 109, 181, 0.9));
        border-radius: 50% 50% 0 0;
        box-shadow: 0 5px 6px rgba(255, 132, 203, 0.4);
      }

      .player-head.head-cap::after {
        content: "";
        position: absolute;
        width: 60px;
        height: 16px;
        top: -12px;
        left: 50%;
        transform: translateX(-50%);
        background: linear-gradient(180deg, #f5deb3, #d8c18c);
        border-radius: 12px 12px 6px 6px;
        border-bottom: 2px solid rgba(0, 0, 0, 0.2);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.25);
      }

      .player-meta {
        text-align: center;
        display: flex;
        flex-direction: column;
        gap: 0.2rem;
      }

      .player-title {
        font-weight: 600;
      }

      .player-status {
        font-size: 0.8rem;
        color: var(--muted);
      }

      .player-stats {
        display: flex;
        gap: 0.6rem;
        font-size: 0.8rem;
        color: var(--muted);
      }

      .game-shell {
        position: relative;
        background: var(--panel-alt);
        border-radius: 28px;
        border: 1px solid var(--border);
        padding: 2rem 1.8rem 1.5rem;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        box-shadow: 0 18px 35px rgba(3, 4, 10, 0.7);
        min-height: 200px;
      }

      .word-display {
        width: fit-content;
        max-width: 100%;
        margin: auto;
        display: flex;
        justify-content: center;
        align-items: center;
        gap: clamp(0.6rem, 2vw, 1.4rem);
        flex-wrap: nowrap;
        overflow-x: hidden;
        font-size: clamp(1.75rem, 3vw, 2.4rem);
        text-align: center;
        padding: 1.25rem clamp(0.75rem, 2vw, 1.5rem) 0.35rem;
      }

      .word-display.word-display--hidden {
        visibility: hidden;
        opacity: 0;
        pointer-events: none;
        height: 0;
      }

      .word-placeholder {
        position: absolute;
        inset: 16px;
        margin: auto;
        display: none;
        width: min(40ch, calc(100% - 32px));
        max-width: 100%;
        max-height: calc(100% - 32px);
        align-items: center;
        justify-content: center;
        text-align: center;
        color: rgba(230, 234, 239, 0.75);
        font-size: 1.35rem;
        font-weight: 500;
        letter-spacing: 0.02rem;
        text-transform: none;
        transition: opacity 0.2s ease;
        padding: 0.75rem 1.5rem;
        border: 1px dashed rgba(255, 255, 255, 0.2);
        border-radius: 12px;
        background: transparent;
        pointer-events: none;
      }

      .word-placeholder.is-visible {
        display: flex;
        opacity: 1;
      }

      .word-tile {
        flex: 0 0 auto;
        width: clamp(48px, 4vw, 62px);
        height: clamp(48px, 4vw, 68px);
        border-bottom: 3px solid rgba(255, 255, 255, 0.35);
        display: flex;
        justify-content: center;
        align-items: center;
        color: transparent;
        font-size: clamp(2rem, 3vw, 2.6rem);
        letter-spacing: 0.12rem;
        font-weight: 600;
      }

      .word-tile.is-filled {
        border-color: var(--accent);
        color: var(--text);
      }

      .word-display.word-display--preview .word-tile {
        border-bottom-color: rgba(255, 255, 255, 0.45);
      }

      .word-tile.word-tile--preview {
        color: var(--text);
        opacity: 0.92;
      }

      .controls-shell {
        background: var(--panel);
        border-radius: 28px;
        border: 1px solid var(--border);
        padding: 1.4rem;
        display: grid;
        gap: 1.5rem;
        box-shadow: 0 18px 35px rgba(3, 4, 10, 0.7);
      }

      .controls-shell.is-hidden .info-panel {
        opacity: 0;
        visibility: hidden;
        pointer-events: none;
        height: 0;
        margin: 0;
      }

      .start-action-shell {
        display: flex;
        justify-content: center;
        margin-top: 0.5rem;
      }

      .start-action .solid-btn {
        min-width: 220px;
        font-size: 1rem;
      }

      .start-player-shell {
        background: transparent;
        border-radius: 20px;
        padding: 0.25rem 0.5rem 0.75rem;
        transition: opacity 0.2s ease, visibility 0.2s ease;
      }

      .start-player-shell.is-hidden {
        opacity: 0;
        visibility: hidden;
        pointer-events: none;
        height: 0;
        margin: 0;
      }

      .start-player-menu {
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
      }

      .start-player-header {
        display: flex;
        align-items: center;
        gap: 0.6rem;
        justify-content: flex-start;
      }

      .start-player-header .reveal-button {
        margin-left: auto;
      }

      .start-player-menu__list {
        display: flex;
        gap: 0.5rem;
        flex-wrap: wrap;
      }

      .start-player-menu__list .muted {
        color: var(--muted);
        font-size: 0.9rem;
      }

      .starting-player-option {
        border-radius: 999px;
        border: 1px solid var(--theme-border);
        padding: 0.35rem 0.9rem;
        background: rgba(255, 255, 255, 0.04);
        color: var(--text);
        font: inherit;
        cursor: pointer;
        transition: border-color 0.2s ease, background 0.2s ease, transform 0.18s ease, box-shadow 0.2s ease;
      }

      .starting-player-option.is-active {
        border-color: var(--theme-border);
        background: var(--theme-bg-weak);
      }

      .starting-player-option:hover {
        border-color: var(--theme-border);
        background: var(--theme-bg-weak);
        transform: translateY(-1px) scale(1.02);
        box-shadow: 0 8px 18px rgba(0, 0, 0, 0.22);
      }

      .mode-row.is-hidden,
      .header-actions.is-hidden {
        display: none;
      }

      .start-action-shell,
      .finish-action-shell {
        display: flex;
        justify-content: center;
        margin-top: 0.5rem;
      }

      .start-action-shell.is-hidden {
        display: none;
      }

      .start-action {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 0.75rem;
        flex-wrap: wrap;
      }

      .start-action .solid-btn,
      #change-word-btn,
      #restart-btn {
        min-width: 220px;
        font-size: 1rem;
      }
      .finish-action-shell.is-hidden {
        display: none;
      }

      .finish-action {
        position: relative;
        display: inline-flex;
        justify-content: center;
        align-items: center;
      }

      .finish-action__confirm {
        position: absolute;
        top: -100%;
        left: 50%;
        transform: translate(-50%, -0.5rem);
        width: min(220px, 100%);
        padding: 0.8rem;
        background: rgba(7, 9, 20, 0.95);
        border-radius: 18px;
        border: 1px solid rgba(255, 255, 255, 0.15);
        box-shadow: 0 12px 25px rgba(0, 0, 0, 0.35);
        text-align: center;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.15s ease;
        z-index: 10;
        display: none;
      }

      .finish-action__confirm.is-visible {
        opacity: 1;
        pointer-events: auto;
        display: inline-flex;
        flex-direction: column;
        align-items: center;
      }

      .finish-action__confirm-actions {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 0.5rem;
        margin-top: 0.65rem;
      }

      #restart-confirm .solid-btn,
      #restart-confirm .ghost-btn {
        display: inline-flex;
        visibility: visible;
        opacity: 1;
      }

      .letter-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(44px, 1fr));
        gap: 0.55rem;
      }

      .letter-key {
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.12);
        background: rgba(255, 255, 255, 0.05);
        color: var(--text);
        padding: 0.5rem 0;
        font-weight: 600;
        letter-spacing: 0.08rem;
      }

      .letter-key:hover:not(:disabled) {
        border-color: rgba(125, 251, 255, 0.7);
        background: rgba(125, 251, 255, 0.08);
      }

      .letter-key:disabled {
        opacity: 0.35;
        cursor: not-allowed;
      }

      .letter-key[data-used] {
        background: rgba(255, 255, 255, 0.08);
        border-color: rgba(255, 255, 255, 0.2);
        color: rgba(255, 255, 255, 0.5);
      }

      body.hide-buttons .letter-key {
        opacity: 1;
        pointer-events: auto;
        color: var(--text);
        border-color: rgba(255, 255, 255, 0.12);
        background: rgba(255, 255, 255, 0.05);
      }

      .info-panel {
        display: flex;
        flex-direction: column;
        gap: 0.3rem;
      }

      .info-actions {
        display: flex;
        gap: 0.5rem;
        flex-wrap: wrap;
        justify-content: center;
      }

      .info-line {
        margin: 0;
        font-size: 0.95rem;
        color: var(--muted);
      }

      .selected-word-row {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        min-height: 1.35rem;
      }

      .selected-word-label {
        color: var(--muted);
        font-size: 0.95rem;
      }

      .selected-word-display {
        color: var(--text);
        letter-spacing: 0.08rem;
        font-weight: 600;
        font-size: 0.95rem;
        position: relative;
        display: inline-block;
      }

      .selected-word-display.is-hidden {
        opacity: 0.85;
        letter-spacing: 0.14rem;
        color: rgba(255, 255, 255, 0.7);
        text-shadow: 0 -0.65em currentColor;
      }

      .reveal-button {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 34px;
        height: 34px;
        border-radius: 10px;
        border: 1px solid var(--theme-border);
        background: rgba(255, 255, 255, 0.02);
        color: var(--text);
        transition: background 0.2s ease, border-color 0.2s ease, color 0.2s ease, transform 0.15s ease;
      }

      .reveal-button:hover {
        background: var(--theme-bg-weak);
        border-color: var(--theme-border);
      }

      .reveal-button.is-active {
        background: var(--theme-bg-weak);
        border-color: var(--theme-border);
        color: var(--text);
        box-shadow: 0 0 0 1px var(--theme-border), 0 0 0 6px var(--theme-bg-weak);
      }

      .reveal-button .eye-icon {
        display: block;
        width: 18px;
        height: 18px;
        background-repeat: no-repeat;
        background-position: center;
        background-size: contain;
        filter: brightness(0) saturate(0) invert(1);
        opacity: 1;
        transition: filter 0.2s ease, opacity 0.2s ease;
      }

      .reveal-button .eye-icon[data-eye-state="hidden"] {
        background-image: url("visible.png");
      }

      .reveal-button .eye-icon[data-eye-state="visible"] {
        background-image: url("invisible.png");
      }

      .reveal-button.is-active .eye-icon {
        filter: brightness(0) saturate(0) invert(1);
        opacity: 1;
      }

      .word-tile.word-tile--masked {
        position: relative;
        color: rgba(255, 255, 255, 0.5);
      }

      .word-tile.word-tile--masked::after {
        content: "•";
        position: absolute;
        top: -16px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 0.7em;
        color: rgba(255, 255, 255, 0.8);
        animation: floatDot 1.4s ease-in-out infinite alternate;
      }

      @keyframes floatDot {
        0% {
          transform: translate(-50%, -2px);
        }
        100% {
          transform: translate(-50%, -6px);
        }
      }

      .message {
        margin: 0;
        font-size: 0.95rem;
        color: var(--info);
        min-height: 1.3rem;
      }

      .message[data-tone="error"] {
        color: var(--error);
      }

      .message[data-tone="success"] {
        color: var(--accent);
      }

      @keyframes sway {
        0% {
          transform: rotate(-4deg);
        }

        50% {
          transform: rotate(4deg);
        }

        100% {
          transform: rotate(-4deg);
        }
      }

      .player-menu {
        position: fixed;
        inset: 0;
        background: rgba(3, 4, 13, 0.85);
        display: none;
        align-items: center;
        justify-content: center;
        padding: 1rem;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.2s ease;
        z-index: 10;
      }

      .player-selector {
        position: fixed;
        inset: 0;
        background: rgba(3, 4, 13, 0.8);
        display: none;
        align-items: center;
        justify-content: center;
        padding: 1rem;
        pointer-events: none;
        opacity: 0;
        z-index: 15;
        transition: opacity 0.2s ease;
      }

      .player-selector.is-open {
        display: flex;
        pointer-events: auto;
        opacity: 1;
      }

      .player-selector-card {
        width: min(520px, 100%);
        max-width: 640px;
        max-height: min(85vh, 720px);
        background: rgba(14, 20, 36, 0.95);
        border-radius: 24px;
        border: 1px solid rgba(255, 255, 255, 0.08);
        padding: 2rem 1.5rem;
        box-shadow: 0 30px 60px rgba(3, 4, 10, 0.8);
        display: flex;
        flex-direction: column;
        gap: 1rem;
        overflow: auto;
      }

      .player-selector-list {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
      }

      .player-selector-button {
        flex: 1 1 140px;
        padding: 0.65rem 0.9rem;
        border-radius: 999px;
        border: 1px solid var(--theme-border);
        background: rgba(255, 255, 255, 0.02);
        color: var(--text);
        font: inherit;
        cursor: pointer;
        transition: background 0.2s ease, border 0.2s ease;
      }

      .player-selector-button.is-selected {
        background: var(--theme-bg-weak);
        border-color: var(--theme-border);
      }

      .player-selector-actions {
        display: flex;
        gap: 0.65rem;
        flex-wrap: wrap;
        justify-content: flex-end;
      }

      #player-selector-cancel {
        order: -1;
      }

      #player-selector-confirm:hover {
        transform: translateY(-1px);
        filter: brightness(1.03);
        box-shadow: 0 10px 20px rgba(0, 0, 0, 0.35);
        border-color: var(--theme-border);
      }

      .traitor-banner {
        margin-top: 0.4rem;
        font-weight: 600;
        color: rgba(255, 255, 255, 0.9);
        opacity: 0;
        transform: translateY(8px);
        transition: opacity 0.3s ease, transform 0.3s ease;
        text-align: center;
      }

      .traitor-banner.is-visible {
        opacity: 1;
        transform: translateY(0);
      }

      .traitor-callout {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.6s ease;
        z-index: 20;
        background: rgba(0, 0, 0, 0.96);
        backdrop-filter: blur(12px);
      }

      .traitor-callout.is-visible {
        opacity: 1;
      }

      .traitor-callout__text {
        font-size: clamp(2.5rem, 5vw, 4.6rem);
        text-align: center;
        font-weight: 700;
        color: #f4f9ff;
        text-transform: uppercase;
        letter-spacing: 0.28rem;
        text-shadow: 0 20px 40px rgba(0, 0, 0, 0.8);
        padding: 1.5rem 2.5rem;
      }

      .player-menu.is-open {
        display: flex;
        opacity: 1;
        pointer-events: auto;
      }

      .player-menu-card {
        width: min(560px, 100%);
        max-width: 680px;
        max-height: min(90vh, 760px);
        background: rgba(14, 20, 36, 0.95);
        border-radius: 24px;
        border: 1px solid rgba(255, 255, 255, 0.08);
        padding: 1.75rem;
        box-shadow: 0 30px 60px rgba(3, 4, 10, 0.8);
        display: flex;
        flex-direction: column;
        gap: 1rem;
        overflow: auto;
      }

      .player-menu-card h2 {
        margin: 0;
        font-size: 1.1rem;
        letter-spacing: 0.05rem;
      }

      .player-menu-card input {
        width: 100%;
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.2);
        background: rgba(255, 255, 255, 0.04);
        padding: 0.9rem 1rem;
        color: var(--text);
        font: inherit;
      }

      .player-menu-card .menu-label {
        margin: 0;
      }

      .accessory-picker {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 0.6rem;
      }

      .accessory-button {
        border-radius: 999px;
        border: 1px solid var(--theme-border);
        background: rgba(255, 255, 255, 0.02);
        padding: 0.65rem;
        color: var(--text);
        font: inherit;
        transition: border-color 0.18s ease, background 0.18s ease, transform 0.18s ease, box-shadow 0.18s ease;
      }

      .accessory-button.is-selected {
        background: var(--theme-bg-weak);
        border-color: var(--theme-border);
        transform: translateY(-1px) scale(1.01);
      }

      .accessory-button:hover {
        border-color: var(--theme-border);
        background: var(--theme-bg-weak);
        transform: translateY(-1px);
        box-shadow: 0 6px 16px rgba(0, 0, 0, 0.25);
      }

      .player-preview {
        border-radius: 20px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        padding: 0.9rem;
        background: rgba(255, 255, 255, 0.02);
      }

      .player-placeholder.preview {
        gap: 0.3rem;
      }

      .menu-actions {
        display: flex;
        gap: 0.6rem;
        flex-wrap: wrap;
        justify-content: flex-end;
      }

      .menu-actions button:hover {
        transform: translateY(-1px) scale(1.02);
        box-shadow: 0 10px 24px rgba(0, 0, 0, 0.25);
      }

      .library-overlay,
      .finish-overlay,
      .reviews-overlay {
        position: fixed;
        inset: 0;
        background: rgba(2, 3, 8, 0.92);
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 1rem;
        opacity: 0;
        pointer-events: none;
        visibility: hidden;
        transition: opacity 0.35s ease, visibility 0.35s ease;
        z-index: 12;
        backdrop-filter: blur(6px);
      }

      .library-overlay.is-open,
      .finish-overlay.is-open,
      .reviews-overlay.is-open {
        opacity: 1;
        pointer-events: auto;
        visibility: visible;
      }

      .library-card {
        width: min(620px, 100%);
        max-width: 760px;
        max-height: min(90vh, 780px);
        background: rgba(17, 23, 42, 0.95);
        border-radius: 26px;
        border: 1px solid rgba(255, 255, 255, 0.08);
        padding: 1.5rem;
        box-shadow: 0 30px 60px rgba(3, 4, 10, 0.85);
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        overflow: auto;
      }

      .library-card__header {
        display: flex;
        align-items: center;
        justify-content: space-between;
      }

      .library-card h3 {
        margin: 0;
        font-size: 1rem;
      }

      .library-card input {
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.2);
        background: rgba(255, 255, 255, 0.04);
        padding: 0.8rem 1rem;
        color: var(--text);
        font: inherit;
      }

      .library-custom {
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
      }

      .custom-row {
        display: flex;
        gap: 0.5rem;
      }

      .library-custom input {
        flex: 1;
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.2);
        background: rgba(255, 255, 255, 0.04);
        padding: 0.8rem 1rem;
        color: var(--text);
        font: inherit;
      }

      .library-list {
        max-height: 320px;
        overflow-y: auto;
        display: grid;
        gap: 0.4rem;
      }
      .library-random {
        display: flex;
        flex-direction: column;
        gap: 0.4rem;
        margin-top: 0.5rem;
      }
      .library-random__row {
        display: flex;
        gap: 0.6rem;
        align-items: center;
      }
      .library-random__word {
        flex: 1;
        font-weight: 600;
        color: var(--text);
        padding: 0.4rem 0.5rem;
        border-radius: 12px;
        background: rgba(255, 255, 255, 0.05);
      }

      .library-word {
        border-radius: 12px;
        border: 1px solid var(--theme-border);
        background: rgba(255, 255, 255, 0.02);
        color: var(--text);
        padding: 0.65rem 0.85rem;
        text-align: left;
        font: inherit;
        cursor: pointer;
        transition: background 0.2s ease, border 0.2s ease;
      }

      .library-word:hover {
        background: var(--theme-bg-weak);
        border-color: var(--theme-border);
      }

      .reviews-card {
        width: min(860px, 95vw);
        max-width: 900px;
        max-height: min(92vh, 780px);
        background: rgba(17, 23, 42, 0.95);
        border-radius: 26px;
        border: 1px solid rgba(255, 255, 255, 0.08);
        padding: 1.5rem 1.75rem;
        box-shadow: 0 30px 60px rgba(3, 4, 10, 0.85);
        display: flex;
        flex-direction: column;
        gap: 1rem;
        overflow: auto;
      }

      .reviews-card__header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 1rem;
      }

      .reviews-card__eyebrow {
        margin: 0;
        text-transform: uppercase;
        letter-spacing: 0.08rem;
        font-size: 0.8rem;
        color: rgba(255, 255, 255, 0.65);
      }

      .reviews-card h3 {
        margin: 0.15rem 0 0;
      }

      .review-form {
        display: flex;
        flex-direction: column;
        gap: 0.6rem;
      }

      .review-form__row {
        display: flex;
        gap: 0.5rem;
      }

      .review-form input,
      .review-form textarea {
        width: 100%;
        border-radius: 14px;
        border: 1px solid rgba(255, 255, 255, 0.2);
        background: rgba(255, 255, 255, 0.04);
        color: var(--text);
        font: inherit;
        padding: 0.8rem 1rem;
      }

      .review-form textarea {
        resize: vertical;
        min-height: 90px;
      }

      .review-form__actions {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 0.75rem;
        flex-wrap: wrap;
      }

      .review-hint {
        margin: 0;
        color: var(--muted);
        font-size: 0.9rem;
      }

      .review-hint-wrap {
        display: inline-flex;
        align-items: center;
        gap: 0.4rem;
        line-height: 1.2;
        position: relative;
      }

      .review-info-btn {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 28px;
        height: 28px;
        border-radius: 50%;
        border: 1px solid rgba(255, 255, 255, 0.3);
        background: rgba(255, 255, 255, 0.05);
        color: var(--text);
        font-weight: 600;
        cursor: pointer;
        transition: background 0.2s ease, border-color 0.2s ease;
      }

      .review-info-btn:hover,
      .review-info-btn:focus-visible {
        border-color: var(--theme-border);
        background: rgba(255, 255, 255, 0.08);
        outline: none;
      }

      .review-info-popover {
        position: absolute;
        top: calc(100% + 0.4rem);
        left: 0;
        width: min(320px, 90vw);
        background: rgba(2, 4, 12, 0.95);
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 14px;
        padding: 0.85rem 1rem;
        font-size: 0.85rem;
        color: rgba(255, 255, 255, 0.9);
        line-height: 1.4;
        box-shadow: 0 12px 24px rgba(0, 0, 0, 0.55), 0 0 0 1px rgba(255, 255, 255, 0.03);
        opacity: 0;
        transform: translateY(6px);
        pointer-events: none;
        transition: opacity 0.25s ease, transform 0.25s ease;
        z-index: 6;
      }

      .review-info-popover.is-visible {
        opacity: 1;
        transform: translateY(0);
        pointer-events: auto;
      }

      .review-feedback {
        margin: 0;
        font-size: 0.9rem;
        color: var(--text);
      }

      .review-feedback[data-tone="error"] {
        color: var(--error);
      }

      .review-feedback[data-tone="success"] {
        color: var(--accent);
      }

      .reviews-admin-toggle {
        background: transparent;
        border: none;
        color: var(--muted);
        text-decoration: underline dashed;
        padding: 0.35rem 0.6rem;
        border-radius: 8px;
        cursor: pointer;
        opacity: 0.55;
        transition: color 0.2s ease, opacity 0.2s ease, text-decoration-color 0.2s ease;
      }

      .reviews-admin-toggle:hover,
      .reviews-admin-toggle:focus-visible {
        color: var(--text);
        opacity: 0.95;
        text-decoration-color: var(--accent);
      }

      .reviews-admin-toggle:focus-visible {
        outline: 2px solid var(--accent);
        outline-offset: 2px;
      }

      .review-stars {
        display: inline-flex;
        gap: 0.35rem;
        align-items: center;
      }

      .review-star {
        cursor: pointer;
        font-size: 1.25rem;
        color: rgba(255, 255, 255, 0.4);
        transition: color 0.15s ease, transform 0.15s ease;
        background: transparent;
        border: none;
        padding: 0.15rem;
      }

      .review-star:hover,
      .review-star:focus-visible {
        color: var(--vivid);
        transform: scale(1.05) translateY(-1px);
        outline: none;
      }

      .review-star.is-active {
        color: var(--accent);
        transform: scale(1.02);
      }

      .review-star.is-hover {
        color: var(--vivid);
        transform: scale(1.05) translateY(-1px);
      }

      .review-summary {
        color: var(--muted);
        font-size: 0.95rem;
        display: inline-flex;
        gap: 0.35rem;
        align-items: center;
      }

      .review-summary strong {
        color: var(--text);
      }

      .review-categories {
        display: flex;
        gap: 0.5rem;
        margin: 0 0 0.5rem;
        overflow-x: auto;
        padding: 0.1rem 0.1rem 0.25rem;
        scroll-snap-type: x mandatory;
        scrollbar-color: rgba(255, 255, 255, 0.25) transparent;
      }

      .review-category {
        cursor: pointer;
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 12px;
        padding: 0.55rem 0.65rem;
        background: rgba(255, 255, 255, 0.02);
        min-width: 140px;
        flex: 0 0 auto;
        scroll-snap-align: start;
        color: var(--text);
        text-align: left;
        transition: border-color 0.16s ease, background 0.16s ease, transform 0.16s ease;
      }

      .review-category h4 {
        margin: 0;
        font-size: 0.9rem;
        display: flex;
        justify-content: space-between;
        align-items: center;
        color: var(--text);
      }

      .review-category p {
        display: none;
      }

      .review-category.is-active {
        border-color: var(--theme-border);
        background: var(--theme-bg-weak);
        transform: translateY(-1px);
      }

      .review-rating-display {
        display: inline-flex;
        gap: 0.1rem;
        align-items: center;
        color: #ffd447;
        font-size: 0.95rem;
      }

      .review-categories::-webkit-scrollbar {
        height: 6px;
      }
      .review-categories::-webkit-scrollbar-track {
        background: transparent;
      }
      .review-categories::-webkit-scrollbar-thumb {
        background: rgba(255, 255, 255, 0.22);
        border-radius: 999px;
      }
      .reviews-list::-webkit-scrollbar {
        width: 8px;
      }
      .reviews-list::-webkit-scrollbar-track {
        background: transparent;
      }
      .reviews-list::-webkit-scrollbar-thumb {
        background: rgba(255, 255, 255, 0.22);
        border-radius: 999px;
      }

      #review-text::-webkit-scrollbar {
        width: 8px;
      }
      #review-text::-webkit-scrollbar-track {
        background: transparent;
      }
      #review-text::-webkit-scrollbar-thumb {
        background: rgba(255, 255, 255, 0.25);
        border-radius: 999px;
      }

      .review-counter {
        color: var(--muted);
        font-size: 0.85rem;
        margin: 0;
      }

      textarea {
        resize: none;
        overflow: auto;
      }

      #review-text {
        resize: none;
        overflow: auto;
      }

      .reviews-empty {
        margin: 0;
        padding: 0.75rem 0.5rem;
        border-radius: 12px;
        background: rgba(255, 255, 255, 0.03);
        border: 1px dashed rgba(255, 255, 255, 0.12);
        color: rgba(255, 255, 255, 0.75);
      }

      .reviews-list {
        display: flex;
        flex-direction: column;
        gap: 0.65rem;
        overflow-y: auto;
        padding-right: 0.25rem;
      }

      .review-item {
        border-radius: 16px;
        border: 1px solid var(--theme-border);
        background: linear-gradient(180deg, rgba(255, 255, 255, 0.03), rgba(255, 255, 255, 0.05));
        padding: 0.85rem 1rem;
        display: flex;
        flex-direction: column;
        gap: 0.4rem;
      }

      .review-item.is-mine {
        border-color: var(--theme-border);
        box-shadow: 0 0 0 2px var(--theme-bg-weak), 0 12px 28px rgba(0, 0, 0, 0.25);
        background: linear-gradient(135deg, var(--theme-bg-weak), rgba(45, 215, 255, 0.05));
      }

      .review-item__header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 0.6rem;
      }

      .review-item__author {
        font-weight: 700;
        letter-spacing: 0.01rem;
      }

      .review-item__meta {
        color: var(--muted);
        font-size: 0.9rem;
      }

      .review-item__text {
        margin: 0;
        line-height: 1.4;
      }

      .review-item__actions {
        display: flex;
        gap: 0.5rem;
        flex-wrap: wrap;
      }

      .review-owner-actions {
        display: inline-flex;
        gap: 0.35rem;
      }

      .review-chip {
        display: inline-flex;
        align-items: center;
        gap: 0.25rem;
        padding: 0.25rem 0.55rem;
        border-radius: 10px;
        background: var(--theme-bg-weak);
        color: #e7fbff;
        font-size: 0.85rem;
        border: 1px solid var(--theme-border);
        letter-spacing: 0.01rem;
      }

      .review-divider {
        width: 100%;
        height: 1px;
        background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.18), transparent);
        margin: 0.35rem 0;
      }

      .review-vote {
        display: inline-flex;
        align-items: center;
        gap: 0.35rem;
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.2);
        background: rgba(255, 255, 255, 0.03);
        color: var(--text);
        padding: 0.4rem 0.65rem;
        font-weight: 600;
        transition: background 0.15s ease, border-color 0.15s ease, transform 0.15s ease;
      }

      .review-vote .vote-count {
        font-weight: 700;
      }

      .review-vote.is-active {
        border-color: var(--theme-border);
        background: var(--theme-bg-weak);
        color: #e7fbff;
      }

      .review-vote:hover {
        border-color: var(--theme-border);
        background: var(--theme-bg-weak);
        transform: translateY(-1px);
        color: #e7fbff;
      }

      .review-action:hover {
        transform: translateY(-1px);
        border-color: var(--theme-border);
        background: var(--theme-bg-weak);
      }

      .finish-card {
        width: min(760px, 100%);
        background: transparent;
        border-radius: 24px;
        border: none;
        padding: 2rem 1.5rem;
        box-shadow: none;
        text-align: center;
        display: grid;
        gap: 1.2rem;
        justify-items: center;
        overflow: visible;
      }

      .finish-card p {
        margin: 0;
        font-size: 1rem;
        color: var(--text);
      }

      .finish-card p.finish-text {
        font-size: 60px !important;
        font-weight: 700;
        color: #f7fbff;
        letter-spacing: 0.06rem;
        white-space: nowrap;
        text-shadow: 0 10px 25px rgba(0, 0, 0, 0.6);
        opacity: 0;
        transform: translateX(-120%);
        line-height: 1.05;
      }

      .finish-text.is-animating {
        animation: result-slide 3.6s ease-in-out forwards;
      }

      .finish-scoreboard {
        width: min(540px, 100%);
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
        padding: 0.75rem 1rem 0.25rem;
        background: rgba(255, 255, 255, 0.03);
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 14px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
        opacity: 0;
        transform: translateY(12px);
        visibility: hidden;
        pointer-events: none;
        transition: opacity 0.35s ease, transform 0.35s ease;
      }

      .finish-scoreboard.is-visible {
        opacity: 1;
        transform: translateY(0);
        visibility: visible;
        pointer-events: auto;
      }

      .finish-scoreboard__word {
        margin: 0;
        color: rgba(255, 255, 255, 0.85);
        font-weight: 600;
        letter-spacing: 0.03rem;
      }

      .finish-scoreboard__list {
        display: grid;
        gap: 0.25rem;
      }

      .finish-scoreboard__row {
        display: grid;
        grid-template-columns: 52px 1fr 120px;
        align-items: center;
        padding: 0.4rem 0.6rem;
        border-radius: 10px;
        background: rgba(255, 255, 255, 0.02);
        border: 1px solid rgba(255, 255, 255, 0.05);
      }

      .finish-scoreboard__rank {
        font-weight: 700;
        color: var(--accent);
      }

      .finish-scoreboard__name {
        text-align: left;
        font-weight: 600;
      }

      .finish-scoreboard__errors {
        text-align: right;
        color: rgba(255, 255, 255, 0.8);
      }

      .finish-close-btn {
        display: inline-flex;
        margin-top: 0.4rem;
        opacity: 0;
        transform: translateY(8px);
        visibility: hidden;
        pointer-events: none;
        transition: opacity 0.25s ease, transform 0.25s ease;
      }

      .finish-close-btn.is-visible {
        opacity: 1;
        transform: translateY(0);
        visibility: visible;
        pointer-events: auto;
      }

      @keyframes result-slide {
        0% {
          transform: translateX(-140%) rotate(0deg) scale(1);
          opacity: 0;
        }
        18% {
          transform: translateX(-25%) rotate(3deg) scale(1.18);
          opacity: 1;
        }
        35% {
          transform: translateX(0) rotate(3deg) scale(1.22);
          opacity: 1;
        }
        45% {
          transform: translateX(0) rotate(3deg) scale(1.22);
          opacity: 1;
        }
        70% {
          transform: translateX(40%) rotate(1deg) scale(1.05);
          opacity: 0.85;
        }
        100% {
          transform: translateX(160%) rotate(0deg) scale(1);
          opacity: 0;
        }
      }

      @media (max-width: 900px) {
        .game-shell,
        .controls-shell,
        .players-shell {
          border-radius: 20px;
        }

        .accessory-picker {
          grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
        }

        .header-actions {
          justify-content: center;
        }
      }
    </style>
  </head>
  <body>
    <main class="app-shell">
      <header class="app-header">
        <div class="volume-control" aria-label="Volumes do jogo">
          <div class="volume-row">
            <label for="volume-slider">Volume da música</label>
            <input id="volume-slider" type="range" min="0" max="100" value="70" />
            <input id="volume-value" class="volume-value" aria-live="polite" value="70%" />
          </div>
          <div class="volume-row">
            <label for="sfx-slider">Volume de SFX</label>
            <input id="sfx-slider" type="range" min="0" max="100" value="70" />
            <input id="sfx-value" class="volume-value" aria-live="polite" value="70%" />
          </div>
        </div>
        <div class="zoom-panel" aria-label="Controle de zoom">
          <div class="zoom-control">
            <button id="zoom-out" class="zoom-btn" type="button" aria-label="Diminuir zoom">🔍︎-</button>
            <button id="zoom-in" class="zoom-btn" type="button" aria-label="Aumentar zoom">🔍︎+</button>
            <span id="zoom-value" class="zoom-value">100%</span>
          </div>
        </div>
        <div class="mode-row">
          <span class="mode-label">Modo</span>
          <button class="mode-button is-active" data-mode="random" type="button">Aleatório</button>
          <button class="mode-button" data-mode="player" type="button" disabled>Jogador escolhe</button>
        </div>
        <div class="header-actions">
          <button id="add-player-btn" class="solid-btn" type="button">Novo jogador</button>
          <div class="bed-legs-control">
            <span>Pernas da cama</span>
            <div class="bed-dropdown" id="bed-dropdown">
              <button class="bed-trigger" type="button" aria-haspopup="listbox" aria-expanded="false">
                <span class="bed-label">4 patas</span>
                <span class="bed-arrow">▼</span>
              </button>
              <div class="bed-menu" role="listbox">
                <button class="bed-option is-active" type="button" data-legs="2">2 patas</button>
                <button class="bed-option" type="button" data-legs="3">3 patas</button>
                <button class="bed-option" type="button" data-legs="4">4 patas</button>
                <button class="bed-option" type="button" data-legs="5">5 patas</button>
                <button class="bed-option" type="button" data-legs="6">6 patas</button>
              </div>
            </div>
          </div>
          <span class="header-divider" aria-hidden="true"></span>
          <button id="reviews-btn" class="ghost-btn" type="button">Avaliações (0)</button>
          <div class="info-wrapper">
            <button class="info-button" type="button" aria-label="Como o jogo funciona">🛈︎</button>
            <div class="info-popover" role="tooltip">
              <strong>Como jogar:</strong> cadastre jogadores, escolha o modo (Aleatório ou Jogador escolhe), sorteie ou selecione a palavra e clique em Iniciar. Cada jogador tenta letras; a quantidade de erros selecionados derrubam a cama.
              <br /><br />
              <strong>Modo Jogador escolhe:</strong> selecione um traidor — ele inveja a cama dos outros e, enquanto eles dormem, precisa quebrar as patas dela. O traidor vence se ninguém acertar.
              <br /><br />
              <strong>Botões:</strong> Novo jogador abre o cadastro, Avaliações mostra as avaliações globais, Pernas da cama define quantas patas a cama terá (dificuldade).
            </div>
          </div>
          <div class="color-switcher">
            <button class="color-switcher__btn" id="color-prev" type="button" aria-label="Cor anterior">&#9664;</button>
            <div class="color-switcher__circle-wrap">
              <div class="color-switcher__circle" id="color-circle" aria-hidden="true"></div>
              <span class="color-switcher__label" id="color-label">azul</span>
            </div>
            <button class="color-switcher__btn" id="color-next" type="button" aria-label="Próxima cor">&#9654;</button>
          </div>
        </div>
        <p id="letter-result" class="letter-result" aria-live="polite"></p>
      </header>
      <div id="player-menu" class="player-menu" aria-hidden="true">
        <div class="player-menu-card">
          <h2>Cadastro do jogador</h2>
          <input id="menu-player-name" type="text" placeholder="Nome do jogador" />
          <p class="menu-label">Acessório</p>
          <div class="accessory-picker" role="group" aria-label="Escolha um acessório">
            <button type="button" class="accessory-button is-selected" data-accessory="none">
              Sem acessório
            </button>
            <button type="button" class="accessory-button" data-accessory="bow">
              🎀 Laço rosa
            </button>
            <button type="button" class="accessory-button" data-accessory="cap">
              🧢 Boné bege
            </button>
            <button type="button" class="accessory-button" data-accessory="blackhat">
              🎩 Chapéu preto
            </button>
            <button type="button" class="accessory-button" data-accessory="bluetiara">
              💙 Tiara azul
            </button>
            <button type="button" class="accessory-button" data-accessory="summerset">
              ☀️ Combo de verão
            </button>
          </div>
          <div class="player-preview">
            <p class="menu-label">Prévia do jogador</p>
          <div class="player-placeholder preview">
            <div class="player-bed preview">
              <img src="download(1).png" alt="Jogador dormindo na cama" class="player-bed__art" id="player-preview-art" />
              <div class="player-bed__legs">
                <span class="player-bed__leg"></span>
                <span class="player-bed__leg"></span>
                <span class="player-bed__leg"></span>
                <span class="player-bed__leg"></span>
              </div>
            </div>
          </div>
          </div>
          <div class="menu-actions">
            <button id="menu-confirm-btn" class="solid-btn" type="button">
              Adicionar jogador
            </button>
            <button id="menu-cancel-btn" class="ghost-btn" type="button">
              Cancelar
            </button>
          </div>
        </div>
      </div>
      <div id="library-overlay" class="library-overlay" aria-hidden="true">
        <div class="library-card">
          <div class="library-card__header">
            <h3>Biblioteca de palavras</h3>
            <button id="library-close" class="ghost-btn tiny" type="button">Fechar</button>
          </div>
          <input id="library-search" type="text" placeholder="Filtrar palavras" />
          <div id="library-list" class="library-list" role="list"></div>
          <div class="library-random">
            <div class="library-random__row">
              <button id="library-random-btn" class="ghost-btn tiny" type="button">Sortear palavra</button>
              <span id="library-random-word" class="library-random__word" aria-live="polite"></span>
            </div>
            <button id="library-random-confirm" class="solid-btn tiny" type="button" disabled>Usar palavra sorteada</button>
          </div>
          <div class="library-custom">
            <p class="menu-label">Sua palavra</p>
            <div class="custom-row">
              <input id="library-custom-word" type="text" placeholder="Digite e pressione Selecionar" maxlength="24" />
              <button id="library-custom-btn" class="solid-btn tiny" type="button">Selecionar</button>
            </div>
          </div>
        </div>
      </div>
      <div id="reviews-overlay" class="reviews-overlay" aria-hidden="true">
        <div class="reviews-card">
          <div class="reviews-card__header">
            <div>
              <p class="reviews-card__eyebrow">Avaliações globais</p>
              <h3>
                Avaliações da comunidade
                <span id="reviews-summary" class="review-summary"></span>
              </h3>
            </div>
            <div style="display:flex; gap:0.4rem; align-items:center;">
              <button id="reviews-admin-toggle" class="reviews-admin-toggle" type="button" aria-expanded="false" aria-controls="reviews-admin-panel">Senha</button>
              <button id="reviews-close" class="ghost-btn tiny" type="button">Fechar</button>
            </div>
          </div>
          <div id="reviews-admin-panel" class="reviews-admin-panel" hidden>
            <form id="reviews-admin-form" class="review-form" style="padding: 0.5rem 0 0;">
              <div class="review-form__row" style="gap:0.4rem; align-items:center;">
                <input id="reviews-admin-password" type="password" placeholder="Senha de admin" autocomplete="off" />
                <button id="reviews-admin-submit" class="solid-btn tiny" type="submit">Desbloquear</button>
              </div>
              <p id="reviews-admin-feedback" class="review-feedback" aria-live="polite" hidden></p>
            </form>
          </div>
          <form id="review-form" class="review-form">
            <div class="review-form__row">
              <input id="review-name" type="text" placeholder="Nome (opcional)" maxlength="40" />
              <p id="review-name-counter" class="review-counter">0/40</p>
            </div>
            <div class="review-form__row" aria-label="Escolha de estrelas" style="gap: 0.6rem; align-items:center;">
              <span style="color: var(--muted); font-size:0.9rem;">Sua nota:</span>
              <div id="review-stars" class="review-stars" role="radiogroup" aria-label="Nota de 1 a 5 estrelas">
                <button type="button" class="review-star" data-rating="1" aria-label="1 estrela">★</button>
                <button type="button" class="review-star" data-rating="2" aria-label="2 estrelas">★</button>
                <button type="button" class="review-star" data-rating="3" aria-label="3 estrelas">★</button>
                <button type="button" class="review-star" data-rating="4" aria-label="4 estrelas">★</button>
                <button type="button" class="review-star" data-rating="5" aria-label="5 estrelas">★</button>
              </div>
            </div>
            <textarea id="review-text" rows="3" maxlength="400" placeholder="Escreva sua avaliação"></textarea>
            <p id="review-text-counter" class="review-counter">0/400</p>
            <div class="review-form__actions">
              <div class="review-hint-wrap">
                <p class="review-hint">Sem nome vira Anonimo#XXXX.</p>
                <button
                  id="review-info-btn"
                  class="review-info-btn"
                  type="button"
                  aria-expanded="false"
                  aria-controls="review-info-popover"
                  aria-label="Mais informações sobre as regras da avaliação"
                >i</button>
                <div
                  id="review-info-popover"
                  class="review-info-popover"
                  role="status"
                  aria-live="polite"
                  aria-hidden="true"
                >
                  Use linguagem respeitosa e construtiva; avaliações com
                  palavrões, insultos ou tentativas de driblar o filtro serão
                  bloqueadas automaticamente.
                </div>
              </div>
              <div class="review-form__row" style="gap: 0.4rem; justify-content: flex-end;">
                <button id="review-cancel-edit" class="ghost-btn tiny" type="button" hidden>Cancelar edicao</button>
                <button id="review-submit" class="solid-btn tiny" type="submit">Publicar</button>
              </div>
            </div>
          </form>
          <p id="review-feedback" class="review-feedback" aria-live="polite" hidden></p>
          <div id="review-categories" class="review-categories" aria-live="polite">
            <button type="button" class="review-category" id="review-category-5" data-filter="star-5">
              <h4>5 ★ <span id="review-count-5">0</span></h4>
            </button>
            <button type="button" class="review-category" id="review-category-4" data-filter="star-4">
              <h4>4 ★ <span id="review-count-4">0</span></h4>
            </button>
            <button type="button" class="review-category" id="review-category-3" data-filter="star-3">
              <h4>3 ★ <span id="review-count-3">0</span></h4>
            </button>
            <button type="button" class="review-category" id="review-category-2" data-filter="star-2">
              <h4>2 ★ <span id="review-count-2">0</span></h4>
            </button>
            <button type="button" class="review-category" id="review-category-1" data-filter="star-1">
              <h4>1 ★ <span id="review-count-1">0</span></h4>
            </button>
            <button type="button" class="review-category" id="review-category-positive" data-filter="positive">
              <h4>Positivas 4-5★ <span id="review-count-positive">0</span></h4>
            </button>
            <button type="button" class="review-category" id="review-category-three" data-filter="neutral">
              <h4>Neutras 3★ <span id="review-count-three">0</span></h4>
            </button>
            <button type="button" class="review-category" id="review-category-critical" data-filter="critical">
              <h4>Críticas 1-2★ <span id="review-count-critical">0</span></h4>
            </button>
          </div>
          <div id="reviews-empty" class="reviews-empty" aria-live="polite">Ninguem avaliou ainda. Seja o primeiro!</div>
          <div id="reviews-list" class="reviews-list" role="list"></div>
        </div>
      </div>
      <div id="player-selector" class="player-selector" aria-hidden="true">
        <div class="player-selector-card">
          <h3>Quem escolhe a palavra?</h3>
          <div id="player-selector-list" class="player-selector-list"></div>
          <div class="player-selector-actions">
            <button id="player-selector-random" class="ghost-btn tiny" type="button">
              Sortear jogador
            </button>
            <button id="player-selector-confirm" class="solid-btn tiny" type="button" disabled>
              Confirmar
            </button>
            <button id="player-selector-cancel" class="ghost-btn tiny" type="button">
              Cancelar
            </button>
          </div>
        </div>
      </div>
      <div id="finish-overlay" class="finish-overlay" aria-hidden="true">
        <div class="finish-card">
          <p id="finish-text" class="finish-text"></p>
          <div id="finish-scoreboard" class="finish-scoreboard" aria-live="polite"></div>
          <button id="finish-close-btn" class="ghost-btn tiny finish-close-btn" type="button">Fechar</button>
        </div>
      </div>
      <div id="traitor-callout" class="traitor-callout" aria-hidden="true">
        <span class="traitor-callout__text"></span>
      </div>
        <section class="players-shell">
          <div class="player-toolbar">
            <p id="player-count">0 jogadores</p>
          </div>
          <div id="player-stage" class="player-stage" aria-live="polite"></div>
        </section>
        <section class="start-player-shell">
          <div class="start-player-menu">
            <div class="start-player-header">
              <p>Quem começa?</p>
              <button id="start-player-reveal" class="reveal-button" type="button" aria-label="Revelar palavra" hidden>
                <span class="eye-icon" aria-hidden="true"></span>
              </button>
            </div>
            <div id="start-player-menu" class="start-player-menu__list"></div>
          </div>
        </section>
      <section class="game-shell">
        <div id="word-display" class="word-display" aria-live="polite"></div>
        <p id="word-placeholder" class="word-placeholder">O painel de palavra será exibido aqui.</p>
      </section>
      <section class="controls-shell">
        <div id="letter-grid" class="letter-grid" role="group" aria-label="Teclado da forca"></div>
        <div class="info-panel">
          <p id="turn-info" class="info-line">Adicione jogadores para começar.</p>
          <p id="progress-info" class="info-line"></p>
          <div id="selected-word-info" class="selected-word-row" aria-live="polite">
            <span id="selected-word-label" class="selected-word-label"></span>
            <span id="selected-word-display" class="selected-word-display"></span>
            <button id="selected-word-reveal" class="reveal-button" type="button" aria-label="Revelar palavra" hidden>
              <span class="eye-icon" aria-hidden="true"></span>
            </button>
          </div>
          <p id="message" class="message" role="status"></p>
          <div id="traitor-banner" class="traitor-banner" aria-live="polite"></div>
        </div>
      </section>
      <section class="start-action-shell">
        <div class="start-action">
          <button id="start-game-btn" class="solid-btn" type="button" disabled>Iniciar partida</button>
          <button id="change-word-btn" class="ghost-btn tiny" type="button" hidden>Alterar palavra</button>
        </div>
      </section>
      <section class="finish-action-shell is-hidden">
        <div class="finish-action">
          <button id="restart-btn" class="ghost-btn tiny" type="button">Terminar rodada</button>
          <div id="restart-confirm" class="finish-action__confirm" aria-live="polite">
            <p>Quer terminar a rodada?</p>
            <div class="finish-action__confirm-actions">
              <button id="restart-confirm-no" type="button" class="ghost-btn tiny">Não</button>
              <button id="restart-confirm-yes" type="button" class="solid-btn tiny">Sim</button>
            </div>
          </div>
        </div>
      </section>
    </main>
    <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
    <script>
      const FALLBACK_WORDS = ["FORCA", "BRASIL", "AMIGO", "AMOR", "JOGO", "PALAVRA", "FUTEBOL", "VITORIA"];
      (async () => {
        const ALPHABET = [
          "A",
          "B",
          "C",
          "D",
          "E",
          "F",
          "G",
          "H",
          "I",
          "J",
          "K",
          "L",
          "M",
          "N",
          "O",
          "P",
          "Q",
          "R",
          "S",
          "T",
          "U",
          "V",
          "W",
          "X",
          "Y",
          "Z"
        ];
        const BODY_PARTS = ["body", "arm-left", "arm-right"];
        const MAX_WRONG = 4;
        const MAX_PLAYERS = 8;
        const LIBRARY_PAGE_LIMIT = 240;
        const DEFAULT_BED_LEGS = 4;
        const MAX_BED_LEGS = 6;
        const MAX_BED_LEG_DISPLAY = 6;
        const REVIEW_STORAGE_KEY = "forca-reviews";
        const REVIEW_VOTES_KEY = "forca-review-votes";
        const REVIEW_OWNER_KEY = "forca-review-owner";
        const OFFENSIVE_REVIEW_TERMS = [
          "porra",
          "merda",
          "puta",
          "foda",
          "foda-se",
          "fuder",
          "cu",
          "ku",
          "caralho",
          "karalho",
          "carai",
          "karai",
          "poha",
          "bosta"
        ];
        const LEET_SUBSTITUTIONS = {
          "0": "o",
          "1": "i",
          "2": "z",
          "3": "e",
          "4": "a",
          "5": "s",
          "6": "g",
          "7": "t",
          "8": "b",
          "9": "g"
        };
        const ZOOM_STORAGE_KEY = "forca-zoom";
        const SUPABASE_URL = "https://rdkjtmazqskdaddwvxke.supabase.co";
        const SUPABASE_KEY = "sb_publishable_0UVjgQskd5c2BOC5eEhEIA_TmxAJ9K5";
        const supabaseClient = window.supabase?.createClient(SUPABASE_URL, SUPABASE_KEY);
        const CONTROL_LOCK_CLASS = "controls-locked";
        let reviewInfoHideTimer = null;
        let bedLegSetting = DEFAULT_BED_LEGS;
        const wordDisplay = document.getElementById("word-display");
        const wordPlaceholder = document.getElementById("word-placeholder");
        const letterGrid = document.getElementById("letter-grid");
        const messageEl = document.getElementById("message");
        const turnInfoEl = document.getElementById("turn-info");
        const progressInfoEl = document.getElementById("progress-info");
        const playerCountEl = document.getElementById("player-count");
        const playerStage = document.getElementById("player-stage");
        const addPlayerBtn = document.getElementById("add-player-btn");
        const startGameBtn = document.getElementById("start-game-btn");
        const modeLabelEl = document.querySelector(".mode-label");
        const appHeader = document.querySelector(".app-header");
        const bedDropdown = document.getElementById("bed-dropdown");
        const bedTrigger = bedDropdown?.querySelector(".bed-trigger");
        const bedMenu = bedDropdown?.querySelector(".bed-menu");
        const bedLegButtons = bedDropdown ? Array.from(bedDropdown.querySelectorAll(".bed-option")) : [];
        const startPlayerMenu = document.getElementById("start-player-menu");
        const controlsShell = document.querySelector(".controls-shell");
        const headerActions = document.querySelector(".header-actions");
        const startActionShell = document.querySelector(".start-action-shell");
        const finishActionShell = document.querySelector(".finish-action-shell");
        const modeRow = document.querySelector(".mode-row");
        const playerModeBtn = document.querySelector('.mode-button[data-mode="player"]');
        const volumeSlider = document.getElementById("volume-slider");
        const volumeValue = document.getElementById("volume-value");
        const sfxSlider = document.getElementById("sfx-slider");
        const sfxValue = document.getElementById("sfx-value");
        const volumeControl = document.querySelector(".volume-control");
        const letterResultEl = document.getElementById("letter-result");
        const playerMenu = document.getElementById("player-menu");
        const menuNameInput = document.getElementById("menu-player-name");
        const accessoryButtons = Array.from(document.querySelectorAll(".accessory-button"));
        const menuConfirmBtn = document.getElementById("menu-confirm-btn");
        const menuCancelBtn = document.getElementById("menu-cancel-btn");
        const modeButtons = document.querySelectorAll(".mode-button");
        const libraryOverlay = document.getElementById("library-overlay");
        const libraryList = document.getElementById("library-list");
        const librarySearch = document.getElementById("library-search");
        const libraryCloseBtn = document.getElementById("library-close");
        const libraryCustomInput = document.getElementById("library-custom-word");
        const libraryCustomBtn = document.getElementById("library-custom-btn");
        const libraryRandomBtn = document.getElementById("library-random-btn");
        const libraryRandomWordEl = document.getElementById("library-random-word");
        const libraryRandomConfirmBtn = document.getElementById("library-random-confirm");
        const reviewsOverlay = document.getElementById("reviews-overlay");
        const reviewsBtn = document.getElementById("reviews-btn");
        const reviewsCloseBtn = document.getElementById("reviews-close");
        const reviewsAdminToggle = document.getElementById("reviews-admin-toggle");
        const reviewsAdminPanel = document.getElementById("reviews-admin-panel");
        const reviewsAdminForm = document.getElementById("reviews-admin-form");
        const reviewsAdminInput = document.getElementById("reviews-admin-password");
        const reviewsAdminFeedback = document.getElementById("reviews-admin-feedback");
        const reviewStarsGroup = document.getElementById("review-stars");
        const reviewStarsButtons = reviewStarsGroup ? Array.from(reviewStarsGroup.querySelectorAll(".review-star")) : [];
        const reviewForm = document.getElementById("review-form");
        const reviewNameInput = document.getElementById("review-name");
        const reviewTextInput = document.getElementById("review-text");
        const reviewInfoBtn = document.getElementById("review-info-btn");
        const reviewInfoPopover = document.getElementById("review-info-popover");
        const reviewNameCounter = document.getElementById("review-name-counter");
        const reviewTextCounter = document.getElementById("review-text-counter");
        const reviewFeedbackEl = document.getElementById("review-feedback");
        const reviewSubmitBtn = document.getElementById("review-submit");
        const reviewCancelEditBtn = document.getElementById("review-cancel-edit");
        const reviewsEmptyState = document.getElementById("reviews-empty");
        const reviewsSummaryEl = document.getElementById("reviews-summary");
        const reviewCategoriesEl = document.getElementById("review-categories");
        const reviewCategoryButtons = reviewCategoriesEl ? Array.from(reviewCategoriesEl.querySelectorAll(".review-category")) : [];
        const reviewCountByStar = {
          1: document.getElementById("review-count-1"),
          2: document.getElementById("review-count-2"),
          3: document.getElementById("review-count-3"),
          4: document.getElementById("review-count-4"),
          5: document.getElementById("review-count-5")
        };
        const reviewCountCritical = document.getElementById("review-count-critical");
        const reviewCountPositive = document.getElementById("review-count-positive");
        const reviewCountThree = document.getElementById("review-count-three");
        const zoomOutBtn = document.getElementById("zoom-out");
        const zoomInBtn = document.getElementById("zoom-in");
        const zoomValueEl = document.getElementById("zoom-value");
        const reviewsList = document.getElementById("reviews-list");
        const libraryCard = document.querySelector(".library-card");
        const playerMenuCard = document.querySelector(".player-menu-card");
        const colorPrevBtn = document.getElementById("color-prev");
        const colorNextBtn = document.getElementById("color-next");
        const colorCircle = document.getElementById("color-circle");
        const colorLabel = document.getElementById("color-label");
        const selectedWordInfoEl = document.getElementById("selected-word-info");
        const selectedWordLabelEl = document.getElementById("selected-word-label");
        const selectedWordDisplayEl = document.getElementById("selected-word-display");
        const selectedWordRevealBtn = document.getElementById("selected-word-reveal");
        const startPlayerRevealBtn = document.getElementById("start-player-reveal");
        const restartBtn = document.getElementById("restart-btn");
        const finishOverlay = document.getElementById("finish-overlay");
        const finishText = document.getElementById("finish-text");
        const finishScoreboard = document.getElementById("finish-scoreboard");
        const finishCloseLateBtn = document.getElementById("finish-close-btn");
        const playerSelector = document.getElementById("player-selector");
        const playerSelectorList = document.getElementById("player-selector-list");
        const playerSelectorRandomBtn = document.getElementById("player-selector-random");
        const playerSelectorConfirmBtn = document.getElementById("player-selector-confirm");
        const playerSelectorCancelBtn = document.getElementById("player-selector-cancel");
        const traitorBanner = document.getElementById("traitor-banner");
        const traitorCallout = document.getElementById("traitor-callout");
        const traitorCalloutText = traitorCallout?.querySelector(".traitor-callout__text");
        const menuPreviewArt = document.getElementById("player-preview-art");
        const changeWordBtn = document.getElementById("change-word-btn");
        const bodyEl = document.body;
        const startPlayerShell = document.querySelector(".start-player-shell");
        const finishConfirm = document.getElementById("restart-confirm");
        const finishConfirmYes = document.getElementById("restart-confirm-yes");
        const finishConfirmNo = document.getElementById("restart-confirm-no");
        const letterButtons = new Map();
        let reviews = [];
        let reviewVotes = {};
        let currentUserId = "";
        let editingReviewId = null;
        let isAdminUnlocked = false;
        let reviewsSyncTimer = null;
        let reviewsChannel = null;
        let currentReviewRating = 0;
        let activeReviewFilter = "all";
        let appZoom = 1;
        let pendingAccessory = "none";
        const THEME_OPTIONS = [
          { name: "rosa", color: "#ff7ac4", text: "#0b0f1b" },
          { name: "verde", color: "#6ef2a9", text: "#0b0f1b" },
          { name: "azul", color: "#2dd7ff", text: "#0b0f1b" },
          { name: "amarelo", color: "#ffd447", text: "#0b0f1b" },
          { name: "laranja", color: "#ff9a3c", text: "#0b0f1b" },
          { name: "vermelho", color: "#ff5f52", text: "#f7fbff" },
          { name: "branco", color: "#f7fbff", text: "#0b0f1b" },
          { name: "preto", color: "#0a0a0f", text: "#f7fbff" },
          { name: "roxo", color: "#b488ff", text: "#0b0f1b" }
        ];
        let themeIndex = THEME_OPTIONS.findIndex(option => option.name === "azul");
        let editingPlayerIndex = null;
        let selectionMode = "random";
        let selectedLibraryWord = "";
        let randomLibraryWord = "";
        let selectedTraitorIndex = null;
        let awaitingLibrarySelection = false;
        let traitorMessageTimer;
        let traitorCalloutTimer;
        let finishOverlayTimer = null;
        let finishCloseRevealTimer = null;
        let startingPlayerIndex = 0;
        let removalCandidateIndex = null;
        let isSelectedWordRevealed = false;
        const ACCESSORY_ART_SOURCES = {
          none: "download(1).png",
          cap: "download(2).png",
          bow: "download(3).png",
          blackhat: "downloadx(1).png",
          bluetiara: "downloadx(2).png",
          summerset: "downloadx(3).png"
        };
        const TRAITOR_ART_SOURCES = {
          none: "download(4).png",
          cap: "download(5).png",
          bow: "download(6).png",
          blackhat: "downloadx(4).png",
          bluetiara: "downloadx(5).png",
          summerset: "downloadx(6).png"
        };
        const LOSE_ART_SOURCES = {
          none: "download(1).png",
          bow: "download(3).png",
          cap: "download(2).png",
          blackhat: "downloadx(1).png",
          bluetiara: "downloadx(2).png",
          summerset: "downloadx(3).png"
        };
        const gameState = {
          players: [],
          activeIndex: 0,
          currentWord: "",
          revealed: [],
          usedLetters: new Set(),
          roundOver: true
        };

        function isTraitorIndex(index) {
          return selectionMode === "player" && selectedTraitorIndex === index;
        }

        function findNextActivePlayerIndex(afterIndex = -1) {
          const total = gameState.players.length;
          if (!total) {
            return 0;
          }
          const baseIndex = afterIndex >= 0 ? afterIndex : -1;
          for (let i = 1; i <= total; i++) {
            const candidate = (baseIndex + i + total) % total;
            if (isTraitorIndex(candidate)) {
              continue;
            }
            const player = gameState.players[candidate];
            if (!player.eliminated) {
              return candidate;
            }
          }
          if (afterIndex >= 0 && !isTraitorIndex(afterIndex) && !gameState.players[afterIndex].eliminated) {
            return afterIndex;
          }
          for (let i = 0; i < total; i++) {
            if (!isTraitorIndex(i)) {
              return i;
            }
          }
          return 0;
        }

        function getActivePlayers() {
          return gameState.players.filter((_, index) => !isTraitorIndex(index));
        }

        const WORD_POOL = await loadWordPool();
        const FINISH_TEXT_ANIM_MS = 3600;

        buildKeyboard();
        renderPlayers();
        setWordDisplayVisibility(false);
        setControlsShellVisibility(false);
        setMainButtonsVisibility(true);
        setRestartVisibility(false);
        setMessage("Use Novo jogador para cadastrar e inicie a partida quando estiver pronto.", "info");
        setLetterResult("");
        renderLibraryList();
        updateModeButtons();
        updateStartButtonState();
        updateModeLabelVisibility();
        updateSelectedWordInfo();
        updateMenuPreview();
        updateChangeWordButtonState();
        if (themeIndex < 0) {
          themeIndex = 2;
        }
        const savedThemeIndex = parseInt(localStorage.getItem("forca-theme-index") || "", 10);
        if (!Number.isNaN(savedThemeIndex)) {
          themeIndex = savedThemeIndex;
        }
        setThemeByIndex(themeIndex, 1);
        applyStoredZoom();
        await initializeReviews();

        addPlayerBtn.addEventListener("click", () => {
          addPlayer();
        });

        modeButtons.forEach(button => {
          button.addEventListener("click", () => {
            const targetMode = button.dataset.mode;
            if (selectionMode === targetMode) {
              return;
            }
            selectionMode = targetMode;
            updateModeButtons();
            updateStartButtonState();
            updateChangeWordButtonState();
            updateModeLabelVisibility();
            isSelectedWordRevealed = false;
            setMessage(
              selectionMode === "player"
                ? "Modo Jogador escolhe ativado. Selecione o traidor; a biblioteca abrirá automaticamente."
                : "Modo Aleatório ativado."
            );
            if (selectionMode === "player") {
              beginPlayerSelectionFlow();
            }
            if (selectionMode === "random") {
              clearWordPreview();
              setWordDisplayVisibility(false);
              selectedLibraryWord = "";
              updateSelectedWordInfo();
            }
          });
        });
        accessoryButtons.forEach(button => {
          button.addEventListener("click", () => {
            pendingAccessory = button.dataset.accessory;
            updateAccessorySelection();
            updateMenuPreview();
          });
        });

        if (reviewsAdminToggle) {
          reviewsAdminToggle.addEventListener("click", () => {
            toggleAdminPanel();
          });
        }

        if (reviewsAdminForm) {
          reviewsAdminForm.addEventListener("submit", event => {
            event.preventDefault();
            const value = (reviewsAdminInput?.value || "").trim();
            if (value === "OWNER_OMEGABISCOITOS") {
              isAdminUnlocked = true;
              toggleAdminPanel();
              renderReviewList();
              setAdminFeedback("Modo admin habilitado.", "success");
            } else {
              isAdminUnlocked = false;
              setAdminFeedback("Senha incorreta.", "error");
            }
          });
        }

        if (reviewStarsButtons.length) {
          reviewStarsButtons.forEach(button => {
            button.addEventListener("click", () => {
              const value = parseInt(button.dataset.rating || "0", 10);
              setReviewRating(value);
            });
            button.addEventListener("mouseenter", () => {
              const value = parseInt(button.dataset.rating || "0", 10);
              setReviewHover(value);
            });
            button.addEventListener("mouseleave", () => {
              setReviewHover(0);
            });
            button.addEventListener("focus", () => {
              const value = parseInt(button.dataset.rating || "0", 10);
              setReviewHover(value);
            });
            button.addEventListener("blur", () => {
              setReviewHover(0);
            });
          });
        }

        if (reviewCategoryButtons.length) {
          reviewCategoryButtons.forEach(button => {
            button.addEventListener("click", () => {
              const filter = button.dataset.filter || "all";
              if (activeReviewFilter === filter) {
                activeReviewFilter = "all";
              } else {
                activeReviewFilter = filter;
              }
              renderReviewList();
              updateReviewCategories();
            });
          });
        }

        if (zoomOutBtn) {
          zoomOutBtn.addEventListener("click", () => {
            setZoom(appZoom - 0.05);
          });
        }

        if (zoomInBtn) {
          zoomInBtn.addEventListener("click", () => {
            setZoom(appZoom + 0.05);
          });
        }

        if (reviewNameInput) {
          reviewNameInput.addEventListener("input", updateNameCounter);
        }
        if (reviewTextInput) {
          reviewTextInput.addEventListener("input", updateTextCounter);
        }
        if (reviewInfoBtn && reviewInfoPopover) {
          const handleReviewInfoMouseEnter = () => {
            showReviewInfoPopover();
          };
          const handleReviewInfoMouseLeave = () => {
            scheduleReviewInfoHide();
          };
          reviewInfoBtn.addEventListener("click", event => {
            event.preventDefault();
            const isOpen = reviewInfoPopover.classList.contains("is-visible");
            if (isOpen) {
              hideReviewInfoPopover();
            } else {
              showReviewInfoPopover();
            }
          });
          [reviewInfoBtn, reviewInfoPopover].forEach(element => {
            element.addEventListener("mouseenter", handleReviewInfoMouseEnter);
            element.addEventListener("mouseleave", handleReviewInfoMouseLeave);
          });
          document.addEventListener("click", event => {
            if (!reviewInfoPopover.classList.contains("is-visible")) {
              return;
            }
            const target = event.target;
            const node = target instanceof Node ? target : null;
            if (!node) {
              return;
            }
            if (reviewInfoBtn.contains(node) || reviewInfoPopover.contains(node)) {
              return;
            }
            hideReviewInfoPopover();
          });
        }

        libraryCustomBtn.addEventListener("click", () => {
          const sanitized = sanitizeWordInput(libraryCustomInput.value);
          if (sanitized.length < 3) {
            setMessage("Digite pelo menos 3 letras para a sua palavra.", "error");
            return;
          }
          libraryCustomInput.value = "";
          handleLibraryWordSelection(sanitized, `Sua palavra "${sanitized}" será usada na próxima partida.`);
        });

        libraryList.addEventListener("click", event => {
          const target = event.target.closest(".library-word");
          if (!target) {
            return;
          }
          handleLibraryWordSelection(target.dataset.word, `Palavra "${target.dataset.word}" selecionada. Iniciando partida...`);
        });

        libraryCloseBtn.addEventListener("click", () => {
          closeLibraryOverlay();
        });

        librarySearch.addEventListener("input", () => {
          renderLibraryList(librarySearch.value);
        });

        libraryRandomBtn?.addEventListener("click", () => {
          randomLibraryWord = getRandomWord();
          if (libraryRandomWordEl) {
            libraryRandomWordEl.textContent = randomLibraryWord;
          }
          if (libraryRandomConfirmBtn) {
            libraryRandomConfirmBtn.disabled = false;
          }
        });

        libraryRandomConfirmBtn?.addEventListener("click", () => {
          const word = (libraryRandomWord || libraryRandomWordEl?.textContent || "").trim();
          if (!word) {
            setMessage("Sorteie uma palavra primeiro.", "error");
            return;
          }
          handleLibraryWordSelection(word, `Palavra sorteada: ${word}. Iniciando partida...`);
        });

        reviewsBtn?.addEventListener("click", () => {
          openReviewsOverlay();
        });

        reviewsCloseBtn?.addEventListener("click", () => {
          closeReviewsOverlay();
        });

        reviewsOverlay?.addEventListener("click", event => {
          if (event.target === reviewsOverlay) {
            closeReviewsOverlay();
          }
        });

        reviewForm?.addEventListener("submit", handleReviewSubmit);

        reviewTextInput?.addEventListener("input", () => {
          setReviewFeedback("");
        });

        reviewCancelEditBtn?.addEventListener("click", () => {
          clearEditingState();
          setReviewFeedback("Edicao cancelada.", "info");
        });

        colorPrevBtn?.addEventListener("click", () => {
          setThemeByIndex(themeIndex - 1, -1);
        });

        colorNextBtn?.addEventListener("click", () => {
          setThemeByIndex(themeIndex + 1, 1);
        });

        reviewsList?.addEventListener("click", event => {
          const actionButton = event.target.closest(".review-action");
          if (actionButton) {
            const reviewEl = actionButton.closest(".review-item");
            const action = actionButton.dataset.action;
            if (reviewEl?.dataset.id) {
              if (action === "edit") {
                startEditingReview(reviewEl.dataset.id);
              } else if (action === "delete") {
                deleteReview(reviewEl.dataset.id);
              }
            }
            return;
          }
          const voteButton = event.target.closest(".review-vote");
          if (voteButton) {
            const reviewEl = voteButton.closest(".review-item");
            const direction = voteButton.dataset.vote === "up" ? "up" : "down";
            if (!reviewEl?.dataset.id) {
              return;
            }
            handleReviewVote(reviewEl.dataset.id, direction);
          }
        });

        function toggleWordReveal() {
          if (!selectedLibraryWord || selectionMode !== "player" || !gameState.roundOver) {
            return;
          }
          isSelectedWordRevealed = !isSelectedWordRevealed;
          updateSelectedWordInfo();
        }

        selectedWordRevealBtn?.addEventListener("click", toggleWordReveal);
        startPlayerRevealBtn?.addEventListener("click", toggleWordReveal);

        function refreshBedLegButtons() {
          bedLegButtons.forEach(button => {
            const buttonValue = Number(button.dataset.legs);
            button.classList.toggle("is-active", buttonValue === bedLegSetting);
          });
        }

        function selectBedLegCount(count) {
          if (!bedLegButtons.length) {
            return;
          }
          const parsed = Number(count);
          const normalized = Number.isFinite(parsed) ? parsed : DEFAULT_BED_LEGS;
          const clamped = Math.min(Math.max(normalized, 2), MAX_BED_LEGS);
          bedLegSetting = clamped;
          refreshBedLegButtons();
          const label = bedTrigger?.querySelector(".bed-label");
          if (label) {
            label.textContent = `${bedLegSetting} patas`;
          }
          gameState.players.forEach(player => {
            player.maxBedLegs = bedLegSetting;
            // Ao mudar a configuração, restaura todas as patas; só perde patas dentro da rodada por erro.
            player.bedLegs = bedLegSetting;
          });
          renderPlayers();
        }

        refreshBedLegButtons();
        const bedLabel = bedTrigger?.querySelector(".bed-label");
        if (bedLabel) {
          bedLabel.textContent = `${bedLegSetting} patas`;
        }

        changeWordBtn?.addEventListener("click", () => {
          if (selectionMode !== "player" || selectedTraitorIndex === null) {
            return;
          }
          setMessage("Selecione uma nova palavra para o traidor.", "info");
          openLibraryOverlayForPlayer();
        });

        function openBedMenu() {
          if (!bedDropdown) {
            return;
          }
          bedDropdown.classList.add("is-open");
        }

        function closeBedMenu() {
          if (!bedDropdown) {
            return;
          }
          bedDropdown.classList.remove("is-open");
        }

        bedTrigger?.addEventListener("click", () => {
          if (!bedDropdown) return;
          if (bedDropdown.classList.contains("is-open")) {
            closeBedMenu();
          } else {
            openBedMenu();
          }
        });

        document.addEventListener("click", event => {
          if (!bedDropdown) return;
          if (!bedDropdown.contains(event.target)) {
            closeBedMenu();
          }
        });

        bedLegButtons.forEach(button => {
          button.addEventListener("click", () => {
            const parsed = Number(button.dataset.legs);
            selectBedLegCount(parsed);
            closeBedMenu();
          });
        });

        restartBtn.addEventListener("click", () => {
          if (!gameState.currentWord) {
            return;
          }
          showFinishConfirm();
        });
        finishConfirmYes?.addEventListener("click", finalizeRoundByButton);
        finishConfirmNo?.addEventListener("click", hideFinishConfirm);
        finishCloseLateBtn?.addEventListener("click", closeFinishOverlay);

        menuConfirmBtn.addEventListener("click", () => {
          const payload = {
            name: menuNameInput.value.trim(),
            accessory: pendingAccessory
          };
          try {
            if (editingPlayerIndex !== null) {
              updatePlayer(editingPlayerIndex, payload);
            } else {
              commitPlayer(payload);
            }
          } finally {
            closePlayerMenu();
            renderPlayers();
            updateStartButtonState();
            updateChangeWordButtonState();
          }
        });

        menuCancelBtn.addEventListener("click", () => {
          closePlayerMenu();
        });

        playerMenu.addEventListener("click", event => {
          if (event.target === playerMenu) {
            closePlayerMenu();
          }
        });

        startGameBtn?.addEventListener("click", handleStartAttempt);

        startPlayerMenu?.addEventListener("click", event => {
          if (!gameState.roundOver || !gameState.players.length) {
            return;
          }
          const button = event.target.closest(".starting-player-option");
          if (!button) {
            return;
          }
          const parsed = Number(button.dataset.startIndex);
          if (!Number.isFinite(parsed)) {
            return;
          }
          startingPlayerIndex = parsed;
          renderPlayers();
        });

        playerStage?.addEventListener("click", event => {
          const editTrigger = event.target.closest("[data-edit-player-index]");
          if (editTrigger) {
            if (!gameState.roundOver) {
              setMessage("Não é possível editar um jogador durante a partida.", "error");
              return;
            }
            const index = Number(editTrigger.dataset.editPlayerIndex);
            if (!Number.isFinite(index)) {
              return;
            }
            removalCandidateIndex = null;
            openPlayerMenu(index);
            return;
          }
          const removeTrigger = event.target.closest("[data-remove-player-index]");
          if (removeTrigger) {
            if (!gameState.roundOver) {
              setMessage("Não é possível remover um jogador durante a partida.", "error");
              return;
            }
            const index = Number(removeTrigger.dataset.removePlayerIndex);
            if (!Number.isFinite(index)) {
              return;
            }
            removalCandidateIndex = index;
            renderPlayers();
            return;
          }
          const confirmTrigger = event.target.closest("[data-confirm-action]");
          if (confirmTrigger) {
            const action = confirmTrigger.dataset.confirmAction;
            const index = Number(confirmTrigger.dataset.confirmIndex);
            if (!Number.isFinite(index)) {
              return;
            }
            if (action === "yes") {
              removePlayer(index);
            } else {
              removalCandidateIndex = null;
              renderPlayers();
            }
          }
        });

        function handleStartAttempt() {
          if (!gameState.roundOver) {
            return;
          }
          if (!gameState.players.length) {
            setMessage("Precisa de pelo menos um jogador.", "error");
            return;
          }
          if (selectionMode === "random") {
            const word = getRandomWord();
            selectedTraitorIndex = null;
            startRound(word);
            return;
          }
          if (gameState.players.length < 2) {
            setMessage("Precisa de pelo menos dois jogadores para o modo Jogador escolhe.", "error");
            return;
          }
          if (selectedTraitorIndex === null) {
            setMessage("Selecione quem escolhe a palavra.", "error");
            beginPlayerSelectionFlow();
            return;
          }
          if (!selectedLibraryWord) {
            setMessage("Selecione uma palavra na biblioteca antes de iniciar.", "error");
            openLibraryOverlayForPlayer();
            return;
          }
          startRound();
        }

        let pendingTraitorIndex = null;
        function beginPlayerSelectionFlow() {
          if (gameState.players.length < 2) {
            setMessage("Adicione pelo menos dois jogadores para ativar o modo Jogador escolhe.", "error");
            awaitingLibrarySelection = false;
            return;
          }
          awaitingLibrarySelection = true;
          selectedTraitorIndex = null;
          selectedLibraryWord = "";
          isSelectedWordRevealed = false;
          clearWordPreview();
          setWordDisplayVisibility(false);
          updateSelectedWordInfo();
          updateStartButtonState();
          updateChangeWordButtonState();
          openPlayerSelector();
        }

        function renderPlayerSelectorButtons() {
          if (!playerSelectorList) {
            return;
          }
          playerSelectorList.innerHTML = "";
          gameState.players.forEach((player, index) => {
            const button = document.createElement("button");
            button.type = "button";
            button.className = "player-selector-button";
            button.textContent = player.name;
            button.addEventListener("click", () => selectTraitorCandidate(index));
            if (index === pendingTraitorIndex) {
              button.classList.add("is-selected");
            }
            playerSelectorList.appendChild(button);
          });
          if (playerSelectorConfirmBtn) {
            playerSelectorConfirmBtn.disabled = pendingTraitorIndex === null;
          }
        }

        function selectTraitorCandidate(index) {
          pendingTraitorIndex = index;
          renderPlayerSelectorButtons();
        }

        function openPlayerSelector() {
          pendingTraitorIndex = selectedTraitorIndex;
          renderPlayerSelectorButtons();
          if (playerSelector) {
            playerSelector.classList.add("is-open");
            playerSelector.setAttribute("aria-hidden", "false");
          }
        }

        function closePlayerSelector() {
          if (playerSelector) {
            playerSelector.classList.remove("is-open");
            playerSelector.setAttribute("aria-hidden", "true");
          }
          pendingTraitorIndex = null;
        }

        playerSelectorRandomBtn?.addEventListener("click", () => {
          if (!gameState.players.length) {
            return;
          }
          const randomIndex = Math.floor(Math.random() * gameState.players.length);
          selectTraitorCandidate(randomIndex);
        });

        playerSelectorConfirmBtn?.addEventListener("click", () => {
          if (pendingTraitorIndex === null) {
            return;
          }
          selectedTraitorIndex = pendingTraitorIndex;
          updateChangeWordButtonState();
          closePlayerSelector();
          const traitor = gameState.players[selectedTraitorIndex];
          selectedLibraryWord = "";
          updateSelectedWordInfo();
          openLibraryOverlayForPlayer();
        });

        playerSelectorCancelBtn?.addEventListener("click", () => {
          closePlayerSelector();
          awaitingLibrarySelection = false;
          selectionMode = "random";
          selectedTraitorIndex = null;
          isSelectedWordRevealed = false;
          selectedLibraryWord = "";
          clearWordPreview();
          setWordDisplayVisibility(false);
          updateModeButtons();
          updateStartButtonState();
          updateModeLabelVisibility();
          updateSelectedWordInfo();
          updateChangeWordButtonState();
          setRevealButtonsVisible(false);
          setMessage("Voltando para o modo Aleatório.", "info");
        });

        function openLibraryOverlayForPlayer() {
          awaitingLibrarySelection = true;
          renderLibraryList();
          resetRandomWord();
          if (!libraryOverlay) {
            return;
          }
          libraryOverlay.classList.add("is-open");
          libraryOverlay.setAttribute("aria-hidden", "false");
          runPanelAnimation(libraryCard, false);
          setTimeout(() => librarySearch?.focus(), 100);
        }

        function closeLibraryOverlay(options = {}) {
          const { resetAwaiting = true } = options;
          if (!libraryOverlay) {
            return;
          }
          runPanelAnimation(libraryCard, true);
          libraryOverlay.classList.remove("is-open");
          libraryOverlay.setAttribute("aria-hidden", "true");
          if (resetAwaiting) {
            awaitingLibrarySelection = false;
          }
        }

        function handleLibraryWordSelection(word, infoMessage) {
          if (!word) {
            return;
          }
          selectedLibraryWord = word;
          isSelectedWordRevealed = false;
          resetRandomWord();
          if (infoMessage) {
            setMessage(infoMessage, "info");
          }
          closeLibraryOverlay();
          updateStartButtonState();
          updateSelectedWordInfo();
          if (selectionMode === "player" && awaitingLibrarySelection) {
            awaitingLibrarySelection = false;
          }
          updateChangeWordButtonState();
        }

        function showTraitorBanner(text) {
          if (!traitorBanner) {
            return;
          }
          traitorBanner.textContent = text;
          traitorBanner.classList.add("is-visible");
          clearTimeout(traitorMessageTimer);
          traitorMessageTimer = setTimeout(() => {
            traitorBanner.classList.remove("is-visible");
          }, 3000);
        }

        function showTraitorCallout(text) {
          if (!traitorCallout) {
            return;
          }
          if (traitorCalloutText) {
            traitorCalloutText.textContent = text;
          }
          playTraitorSfx();
          lockControlsForTraitor();
          traitorCallout.classList.add("is-visible");
          traitorCallout.setAttribute("aria-hidden", "false");
          clearTimeout(traitorCalloutTimer);
          traitorCalloutTimer = setTimeout(() => {
            traitorCallout.classList.remove("is-visible");
            traitorCallout.setAttribute("aria-hidden", "true");
          }, 3000);
        }

        function playTraitorSfx() {
          try {
            const cue = new Audio("hammer.mp3");
            cue.volume = sfxVolumeNormalized;
            cue.play().catch(() => {});
          } catch (error) {
            console.error("Não foi possível tocar o som do traidor:", error);
          }
        }

        const IDLE_TRACK_SRC = "track1.mp3";
        const ROUND_TRACK_SRC = "track2.mp3";
        const CLICK_PRIMARY_SRC = "UI-click1.mp3";
        const CLICK_SECONDARY_SRC = "UI-click2.mp3";
        const CORRECT_SFX_SRC = "Correct.mp3";
        const INCORRECT_SFX_SRC = "Incorrect.mp3";
        const SELECT_SFX_SRC = "UI-select.mp3";
        const DEFAULT_VOLUME_PERCENT = 70;
        const DEFAULT_SFX_VOLUME_PERCENT = 70;
        let idleMusic;
        let roundMusic;
        let activeMusic = null;
        let clickPrimary;
        let clickSecondary;
        let selectSfx;
        let correctSfx;
        let incorrectSfx;
        let sfxVolumeNormalized = DEFAULT_SFX_VOLUME_PERCENT / 100;

        function createLoopingTrack(src, volume = 0.6) {
          try {
            const audio = new Audio(src);
            audio.loop = true;
            audio.volume = volume;
            audio.preload = "auto";
            audio.addEventListener("ended", () => {
              audio.currentTime = 0;
              audio.play().catch(() => {});
            });
            return audio;
          } catch (error) {
            console.warn(`Não foi possível carregar ${src}:`, error);
            return null;
          }
        }

        function createSfx(src) {
          try {
            const audio = new Audio(src);
            audio.loop = false;
            audio.volume = sfxVolumeNormalized;
            audio.preload = "auto";
            return audio;
          } catch (error) {
            console.warn(`Não foi possível carregar ${src}:`, error);
            return null;
          }
        }

        function enforceCaretBeforePercent(el) {
          if (!el) return;
          const pos = Math.max(0, (el.value || "").length - 1);
          requestAnimationFrame(() => {
            try {
              el.setSelectionRange(pos, pos);
            } catch (_) {
              /* ignore */
            }
          });
        }

        function setVolume(percent) {
          const normalized = Math.max(0, Math.min(100, Number(percent)));
          const value = normalized / 100;
          if (idleMusic) {
            idleMusic.volume = value;
          }
          if (roundMusic) {
            roundMusic.volume = value;
          }
          if (volumeSlider) {
            volumeSlider.value = String(normalized);
          }
          if (volumeValue) {
            volumeValue.value = `${Math.round(normalized)}%`;
            enforceCaretBeforePercent(volumeValue);
          }
        }

        function setSfxVolume(percent) {
          const normalized = Math.max(0, Math.min(100, Number(percent)));
          sfxVolumeNormalized = normalized / 100;
          if (sfxSlider) {
            sfxSlider.value = String(normalized);
          }
          if (sfxValue) {
            sfxValue.value = `${Math.round(normalized)}%`;
            enforceCaretBeforePercent(sfxValue);
          }
        }

        function stopCurrentMusic() {
          if (!activeMusic) {
            return;
          }
          activeMusic.pause();
          activeMusic.currentTime = 0;
          activeMusic = null;
        }

        function attemptPlayTrack(audio) {
          if (!audio) {
            return;
          }
          try {
            audio.currentTime = 0;
            audio.play().catch(() => {});
          } catch (error) {
            console.warn("Não foi possível iniciar a trilha sonora:", error);
          }
        }

        function playSfx(audio, factor = 1) {
          if (!audio) return;
          try {
            audio.currentTime = 0;
            const vol = Math.max(0, Math.min(1, sfxVolumeNormalized * factor));
            audio.volume = vol;
            audio.play().catch(() => {});
          } catch (error) {
            console.warn("Não foi possível tocar o efeito sonoro:", error);
          }
        }

        function switchToTrack(target) {
          if (!target) {
            stopCurrentMusic();
            return;
          }
          if (activeMusic === target && !target.paused) {
            return;
          }
          stopCurrentMusic();
          activeMusic = target;
          attemptPlayTrack(target);
        }

        function playIdleMusic() {
          switchToTrack(idleMusic);
        }

        function playRoundMusic() {
          switchToTrack(roundMusic);
        }

        function syncRoundMusic() {
          if (gameState.roundOver) {
            playIdleMusic();
          } else {
            playRoundMusic();
          }
        }


        idleMusic = createLoopingTrack(IDLE_TRACK_SRC, 0.55);
        roundMusic = createLoopingTrack(ROUND_TRACK_SRC, 0.65);
        clickPrimary = createSfx(CLICK_PRIMARY_SRC);
        clickSecondary = createSfx(CLICK_SECONDARY_SRC);
        selectSfx = createSfx(SELECT_SFX_SRC);
        correctSfx = createSfx(CORRECT_SFX_SRC);
        incorrectSfx = createSfx(INCORRECT_SFX_SRC);
        setVolume(DEFAULT_VOLUME_PERCENT);
        setSfxVolume(DEFAULT_SFX_VOLUME_PERCENT);
        syncRoundMusic();

        let audioUnlocked = false;
        let autoPlayAttempts = 0;
        function tryAutoPlay() {
          if (audioUnlocked || autoPlayAttempts >= 15) {
            return;
          }
          autoPlayAttempts++;
          const target = activeMusic || idleMusic || roundMusic;
          try {
            const maybe = target?.play?.();
            if (maybe && typeof maybe.then === "function") {
              maybe
                .then(() => {
                  audioUnlocked = true;
                  if (idleMusic) idleMusic.muted = false;
                  if (roundMusic) roundMusic.muted = false;
                })
                .catch(() => {
                  setTimeout(tryAutoPlay, 1200);
                });
            } else {
              setTimeout(tryAutoPlay, 1200);
            }
          } catch (_) {
            setTimeout(tryAutoPlay, 1200);
          }
        }
        tryAutoPlay();
        setTimeout(() => {
          try {
            tryAutoPlay();
          } catch (error) {
            console.warn("Falha ao iniciar áudio automaticamente:", error);
          }
        }, 400);
        const autoPlayInterval = setInterval(() => {
          if (audioUnlocked) {
            clearInterval(autoPlayInterval);
            return;
          }
          tryAutoPlay();
        }, 2000);

        function unlockAudioPlayback() {
          if (audioUnlocked) return;
          audioUnlocked = true;
          // Desmuta e garante que a trilha de espera comece
          if (idleMusic) idleMusic.muted = false;
          if (roundMusic) roundMusic.muted = false;
          playIdleMusic();
          ["click", "pointerdown", "pointermove", "mousemove", "keydown", "touchstart"].forEach(evt => {
            window.removeEventListener(evt, unlockAudioPlayback, { capture: true });
          });
        }
        ["click", "pointerdown", "pointermove", "mousemove", "keydown", "touchstart"].forEach(evt => {
          window.addEventListener(evt, unlockAudioPlayback, { capture: true, once: false });
        });

        document.addEventListener("click", event => {
          const button = event.target.closest("button");
          if (!button) return;
          if (button.matches(".mode-button, #add-player-btn, #start-game-btn, .solid-btn:not(.tiny):not(.player-card__confirm-yes):not(.player-card__confirm-no)")) {
            playSfx(clickPrimary);
            return;
          }
          const secondarySelectors = [
            ".ghost-btn",
            ".accessory-button",
            ".bed-option",
            ".player-selector-button",
            "#player-selector-confirm",
            "#player-selector-cancel",
            "#player-selector-random",
            "#menu-confirm-btn",
            "#menu-cancel-btn",
            "#library-close",
            "#library-random-btn",
            "#library-custom-btn",
            "#library-random-confirm",
            "#review-submit",
            "#review-cancel-edit",
            ".review-vote",
            ".review-action",
            "#start-player-reveal",
            "#change-word-btn",
            "#selected-word-reveal",
            "#restart-btn",
            "#restart-confirm-yes",
            "#restart-confirm-no",
            ".player-card__action",
            ".player-card__confirm-yes",
            ".player-card__confirm-no",
            "#finish-close-btn"
          ];
          if (secondarySelectors.some(sel => button.matches(sel))) {
            playSfx(clickSecondary);
          }
        }, true);

        let lastSelectSfxAt = 0;
        function playSelectSfx() {
          const now = performance.now();
          if (now - lastSelectSfxAt < 80) return;
          lastSelectSfxAt = now;
          playSfx(selectSfx, 0.8);
        }

        document.addEventListener("pointerenter", event => {
          const btn = event.target.closest("button");
          if (!btn || btn.disabled || btn.classList.contains("letter-key")) return;
          playSelectSfx();
        }, true);

        document.addEventListener("focusin", event => {
          const btn = event.target.closest("button");
          if (!btn || btn.disabled || btn.classList.contains("letter-key")) return;
          playSelectSfx();
        });

        volumeSlider?.addEventListener("input", event => {
          setVolume(event.target.value);
        });
        sfxSlider?.addEventListener("input", event => {
          setSfxVolume(event.target.value);
        });
        volumeValue?.addEventListener("input", () => {
          const numeric = parseInt(volumeValue.value.replace(/[^0-9]/g, ""), 10);
          const safeValue = Number.isNaN(numeric) ? 0 : numeric;
          setVolume(safeValue);
          volumeValue.value = `${Math.max(0, Math.min(100, Number(volumeSlider?.value ?? safeValue)))}%`;
          enforceCaretBeforePercent(volumeValue);
        });
        sfxValue?.addEventListener("input", () => {
          const numeric = parseInt(sfxValue.value.replace(/[^0-9]/g, ""), 10);
          const safeValue = Number.isNaN(numeric) ? 0 : numeric;
          setSfxVolume(safeValue);
          sfxValue.value = `${Math.max(0, Math.min(100, Number(sfxSlider?.value ?? safeValue)))}%`;
          enforceCaretBeforePercent(sfxValue);
        });

        function setControlsLocked(locked) {
          if (!bodyEl) {
            return;
          }
          bodyEl.classList.toggle(CONTROL_LOCK_CLASS, locked);
        }

        function lockControlsForTraitor() {
          setControlsLocked(true);
        }

        function unlockControls() {
          setControlsLocked(false);
        }



        async function loadWordPool() {
          try {
            const response = await fetch("words.json");
            if (!response.ok && response.status !== 0) {
              throw new Error(`HTTP ${response.status}`);
            }
            const pool = await response.json();
            if (!Array.isArray(pool) || !pool.length) {
              throw new Error("Lista vazia");
            }
            return pool;
          } catch (error) {
            console.error("Falha ao carregar lista de palavras:", error);
            setMessage("Não foi possível carregar as 5.000 palavras; usando fallback.", "error");
            return [...FALLBACK_WORDS];
          }
        }

        function addPlayer() {
          if (gameState.players.length >= MAX_PLAYERS) {
            setMessage("Limite de jogadores atingido.", "error");
            return;
          }
          openPlayerMenu();
        }

        function commitPlayer({ name, accessory }) {
          if (gameState.players.length >= MAX_PLAYERS) {
            setMessage("Limite de jogadores atingido.", "error");
            return;
          }
          const nextPlayer = {
            name: name || `Jogador ${gameState.players.length + 1}`,
            victories: 0,
            mistakes: 0,
            eliminated: false,
            accessory: accessory || "none",
            guessedLetters: [],
            bedLegs: bedLegSetting,
            maxBedLegs: bedLegSetting,
            scared: false
          };
          gameState.players.push(nextPlayer);
          renderPlayers();
          updateStartButtonState();
          setMessage(`${nextPlayer.name} entrou no jogo.`, "info");
          setLetterResult("");
        }

        function updatePlayer(index, { name, accessory }) {
          const player = gameState.players[index];
          if (!player) {
            return;
          }
          const nextName = name?.trim();
          player.name = nextName || player.name;
          player.accessory = accessory || player.accessory || "none";
          renderPlayers();
          updateStartButtonState();
          updateChangeWordButtonState();
          setMessage(`${player.name} atualizado.`, "info");
        }

        function openPlayerMenu(editIndex = null) {
          editingPlayerIndex = Number.isInteger(editIndex) ? editIndex : null;
          const isEditing = editingPlayerIndex !== null && gameState.players[editingPlayerIndex];
          const targetPlayer = isEditing ? gameState.players[editingPlayerIndex] : null;
          pendingAccessory = targetPlayer?.accessory || "none";
          menuNameInput.value = targetPlayer?.name || "";
          menuConfirmBtn.textContent = isEditing ? "Salvar jogador" : "Adicionar jogador";
          updateAccessorySelection();
          updateMenuPreview();
          playerMenu.classList.add("is-open");
          playerMenu.setAttribute("aria-hidden", "false");
          runPanelAnimation(playerMenuCard, false);
          setTimeout(() => menuNameInput.focus(), 100);
        }

        function closePlayerMenu() {
          runPanelAnimation(playerMenuCard, true);
          playerMenu.classList.remove("is-open");
          playerMenu.setAttribute("aria-hidden", "true");
          editingPlayerIndex = null;
          menuConfirmBtn.textContent = "Adicionar jogador";
          pendingAccessory = "none";
          updateAccessorySelection();
          updateMenuPreview();
        }

        function updateAccessorySelection() {
          accessoryButtons.forEach(button => {
            button.classList.toggle("is-selected", button.dataset.accessory === pendingAccessory);
          });
        }

        function getBedArtSrc(accessory = "none") {
          return ACCESSORY_ART_SOURCES[accessory] || ACCESSORY_ART_SOURCES.none;
        }

        function getTraitorArtSrc(accessory = "none") {
          return TRAITOR_ART_SOURCES[accessory] || TRAITOR_ART_SOURCES.none;
        }

        function getLoseArtSrc(accessory = "none") {
          return LOSE_ART_SOURCES[accessory] || LOSE_ART_SOURCES.none;
        }

        function getLoseStaticArtSrc() {
          return null;
        }

          function updateMenuPreview() {
            if (!menuPreviewArt) {
              return;
            }
            menuPreviewArt.src = getBedArtSrc(pendingAccessory);
            menuPreviewArt.classList.toggle("is-bluetiara", pendingAccessory === "bluetiara");
          }

        function buildKeyboard() {
          letterGrid.innerHTML = "";
          ALPHABET.forEach(letter => {
            const button = document.createElement("button");
            button.type = "button";
            button.className = "letter-key";
            button.textContent = letter;
            button.addEventListener("click", () => handleLetter(letter));
            letterGrid.appendChild(button);
            letterButtons.set(letter, button);
          });
          updateKeyboard();
        }

        function updateKeyboard() {
          letterButtons.forEach((button, letter) => {
            if (gameState.usedLetters.has(letter)) {
              button.setAttribute("data-used", "true");
              button.disabled = true;
            } else {
              button.removeAttribute("data-used");
              button.disabled = gameState.roundOver;
            }
          });
        }

        function handleLetter(letter) {
          if (gameState.roundOver || !gameState.currentWord || gameState.usedLetters.has(letter)) {
            return;
          }
          gameState.usedLetters.add(letter);
          updateKeyboard();
          const current = gameState.players[gameState.activeIndex];
          current.guessedLetters = current.guessedLetters || [];
          if (!current.guessedLetters.includes(letter)) {
            current.guessedLetters.push(letter);
          }
          const guessNorm = normalizeCharForMatch(letter);
          const wordNorm = normalizeForMatch(gameState.currentWord);
          if (wordNorm.includes(guessNorm)) {
            let hits = 0;
            gameState.currentWord.split("").forEach((character, index) => {
              if (normalizeCharForMatch(character) === guessNorm && !gameState.revealed[index]) {
                gameState.revealed[index] = true;
                hits++;
              }
            });
            createWordTiles();
            setMessage(`${letter} aparece ${hits} vez(es)!`, "success");
            setLetterResult(`${current.name} acertou ${letter}.`, "success");
            playSfx(correctSfx);
            if (gameState.revealed.every(Boolean)) {
              endRound(true);
            }
            return;
          }
          current.mistakes++;
          const maxLegs = current.maxBedLegs ?? bedLegSetting;
          current.bedLegs = Math.max(0, maxLegs - current.mistakes);
          setMessage(`${letter} não está na palavra.`, "error");
          setLetterResult(`${current.name} errou com ${letter}.`, "error");
          playSfx(incorrectSfx);
          if (current.mistakes >= MAX_WRONG) {
          current.eliminated = true;
          current.scared = true;
          current.bedLegs = 0;
            setMessage(`${current.name} foi eliminado!`, "error");
            const activePlayers = getActivePlayers();
            if (activePlayers.length && activePlayers.every(player => player.eliminated)) {
              endRound(false);
              return;
            }
          }
          advancePlayer();
          renderPlayers();
        }

        function advancePlayer() {
          if (gameState.players.length <= 1) {
            return;
          }
          const nextIndex = findNextActivePlayerIndex(gameState.activeIndex);
          if (nextIndex !== gameState.activeIndex) {
            gameState.activeIndex = nextIndex;
          }
        }

        function setWordDisplayVisibility(visible, showPlaceholder = !visible) {
          if (wordDisplay) {
            wordDisplay.classList.toggle("word-display--hidden", !visible);
          }
          if (wordPlaceholder) {
            wordPlaceholder.classList.toggle("is-visible", showPlaceholder);
          }
        }

        function renderWordPreview(word) {
          if (!wordDisplay) {
            return;
          }
          clearWordPreview();
          if (!word) {
            return;
          }
          wordDisplay.classList.remove("word-display--hidden");
          wordDisplay.classList.add("word-display--preview");
          wordDisplay.innerHTML = "";
          word.split("").forEach(letter => {
            const tile = document.createElement("span");
            tile.className = "word-tile word-tile--preview";
            tile.textContent = letter;
            wordDisplay.appendChild(tile);
          });
          if (wordPlaceholder) {
            wordPlaceholder.classList.remove("is-visible");
          }
        }

        function renderMaskedPreview(word) {
          if (!wordDisplay) {
            return;
          }
          clearWordPreview();
          if (!word) {
            return;
          }
          wordDisplay.classList.remove("word-display--hidden");
          wordDisplay.classList.add("word-display--preview");
          word.split("").forEach(() => {
            const tile = document.createElement("span");
            tile.className = "word-tile word-tile--preview word-tile--masked";
            tile.textContent = "";
            wordDisplay.appendChild(tile);
          });
          if (wordPlaceholder) {
            wordPlaceholder.classList.remove("is-visible");
          }
        }

        function clearWordPreview() {
          if (!wordDisplay) {
            return;
          }
          wordDisplay.innerHTML = "";
          wordDisplay.classList.remove("word-display--preview", "word-display--hidden");
        }

        function setStartPlayerShellVisibility(visible) {
          if (!startPlayerShell) {
            return;
          }
          startPlayerShell.classList.toggle("is-hidden", !visible);
        }

        function setMainButtonsVisibility(visible) {
          if (modeRow) {
            modeRow.classList.toggle("is-hidden", !visible);
          }
          if (headerActions) {
            headerActions.classList.toggle("is-hidden", !visible);
          }
          if (startActionShell) {
            startActionShell.classList.toggle("is-hidden", !visible);
          }
          setStartPlayerShellVisibility(visible);
          if (startGameBtn) {
            startGameBtn.hidden = !visible;
          }
        }

        function setVolumeVisibility(visible) {
          if (volumeControl) {
            volumeControl.classList.toggle("is-hidden", !visible);
          }
        }

        function setHeaderVisibility(visible) {
          if (appHeader) {
            appHeader.classList.toggle("is-hidden", !visible);
          }
        }

        function setRestartVisibility(visible) {
          if (!restartBtn) {
            return;
          }
          if (finishActionShell) {
            finishActionShell.classList.toggle("is-hidden", !visible);
          }
          if (!visible) {
            hideFinishConfirm();
          }
        }

        function setControlsShellVisibility(visible) {
          if (!controlsShell) {
            return;
          }
          controlsShell.classList.toggle("is-hidden", !visible);
        }

        function showFinishConfirm() {
          if (!finishConfirm) {
            return;
          }
          finishConfirm.classList.add("is-visible");
        }

        function hideFinishConfirm() {
          if (!finishConfirm) {
            return;
          }
          finishConfirm.classList.remove("is-visible");
        }

        function finalizeRoundByButton() {
          if (!gameState.currentWord) {
            hideFinishConfirm();
            return;
          }
          hideFinishConfirm();
          gameState.roundOver = true;
          setWordDisplayVisibility(false);
          setControlsShellVisibility(false);
          setMainButtonsVisibility(true);
          setVolumeVisibility(true);
          setRestartVisibility(false);
          updateModeLabelVisibility();
          updateKeyboard();
          updateStartButtonState();
          const word = gameState.currentWord;
          const entries = gameState.players
            .map((player, index) => ({ ...player, index }))
            .sort((a, b) => a.mistakes - b.mistakes || a.index - b.index);
          showNoWinnerOverlay(word, entries);
          setMessage(`Partida finalizada pelo botão. A palavra era ${word}.`, "info");
          unlockControls();
          syncRoundMusic();
        }

        function ensureStartingPlayerIndex() {
          if (!gameState.players.length) {
            startingPlayerIndex = 0;
            return 0;
          }
          if (startingPlayerIndex < 0) {
            startingPlayerIndex = 0;
          }
          if (startingPlayerIndex >= gameState.players.length) {
            startingPlayerIndex = gameState.players.length - 1;
          }
          return startingPlayerIndex;
        }

        function renderStartingPlayerMenu() {
          if (!startPlayerMenu) {
            return;
          }
          if (!gameState.players.length) {
            startPlayerMenu.innerHTML = "<span class='muted'>Adicione jogadores para começar.</span>";
            return;
          }
          const targetIndex = ensureStartingPlayerIndex();
          startPlayerMenu.innerHTML = gameState.players
            .map(
              (player, index) => `<button type="button" class="starting-player-option${index === targetIndex ? " is-active" : ""}" data-start-index="${index}">${player.name}</button>`
            )
            .join("");
        }

        function renderPlayers() {
          if (!gameState.roundOver) {
            removalCandidateIndex = null;
          }
          playerStage.innerHTML = "";
          const normalizedStartingIndex = ensureStartingPlayerIndex();
          if (!gameState.players.length) {
            playerCountEl.textContent = "0 jogadores";
            playerStage.innerHTML = '<p class="empty-state">Use "Novo jogador" para adicionar o primeiro jogador.</p>';
            updateInfo();
            renderStartingPlayerMenu();
            return;
          }
          playerCountEl.textContent = `${gameState.players.length} ${gameState.players.length === 1 ? "jogador" : "jogadores"}`;
          if (removalCandidateIndex !== null && (removalCandidateIndex < 0 || removalCandidateIndex >= gameState.players.length)) {
            removalCandidateIndex = null;
          }
          gameState.players.forEach((player, index) => {
            const card = document.createElement("article");
            const isActivePlayer = !gameState.roundOver && index === gameState.activeIndex && !player.eliminated;
            const canRemove = gameState.roundOver;
            const isTraitor = isTraitorIndex(index);
            const showTraitorUi = isTraitor && !gameState.roundOver;
            const showElimOverlay = player.eliminated && !gameState.roundOver;
            const cardClasses = ["player-card"];
            if (canRemove) {
              cardClasses.push("player-card--removable");
            }
            if (isActivePlayer) {
              cardClasses.push("is-active");
            }
            if (removalCandidateIndex === index) {
              cardClasses.push("is-confirming");
            }
            if (index === normalizedStartingIndex) {
              cardClasses.push("is-starting");
            }
            if (showElimOverlay) {
              cardClasses.push("is-eliminated");
            }
            card.className = cardClasses.join(" ");
          const maxLegs = Math.max(1, Math.min(player.maxBedLegs ?? bedLegSetting, MAX_BED_LEG_DISPLAY));
          const activeLegs = Math.max(0, Math.min(maxLegs, player.bedLegs ?? maxLegs));
          const bedLegsMarkup = Array.from({ length: maxLegs }, (_, legIndex) => {
            const isActive = legIndex < activeLegs;
            return `<span class="player-bed__leg${isActive ? "" : " is-gone"}"></span>`;
          }).join("");
          const artSrc = player.eliminated
            ? getLoseArtSrc(player.accessory)
            : showTraitorUi
              ? getTraitorArtSrc(player.accessory)
              : getBedArtSrc(player.accessory);
          const lettersText =
            player.guessedLetters && player.guessedLetters.length ? `Letras: ${player.guessedLetters.join(", ")}` : "Nenhuma letra";
          const lettersMarkup = showTraitorUi ? "" : `<div class="player-letters">${lettersText}</div>`;
          const zzMarkup = showTraitorUi
            ? ""
            : `<span class="zz-callout" aria-hidden="true">Z<span class="zz-callout__lower">z</span></span>`;
          const statusText = showTraitorUi
            ? "Traidor"
            : player.eliminated
              ? "Eliminado"
              : index === gameState.activeIndex
                ? "Vez atual"
                : "Aguardando";
            const statsMarkup = showTraitorUi
              ? ""
              : `<div class="player-stats">
                <span>Vitórias ${player.victories}</span>
                <span>Erros ${player.mistakes}/${MAX_WRONG}</span>
              </div>`;
            const removalMarkup = canRemove
              ? `
            <div class="player-card__remove-panel">
              <div class="player-card__actions">
                <button
                  type="button"
                  class="player-card__action player-card__edit"
                  data-edit-player-index="${index}"
                  aria-label="Editar ${player.name}"
                >
                  ✎
                </button>
                <button
                  type="button"
                  class="player-card__action player-card__remove"
                  data-remove-player-index="${index}"
                  aria-label="Remover ${player.name}"
                >
                  X
                </button>
              </div>
              <div class="player-card__confirm">
                <p>Quer excluir o jogador?</p>
                <div class="player-card__confirm-actions">
                  <button
                    type="button"
                    class="ghost-btn tiny player-card__confirm-no"
                    data-confirm-index="${index}"
                    data-confirm-action="no"
                  >
                    Não
                  </button>
                  <button
                    type="button"
                    class="solid-btn tiny player-card__confirm-yes"
                    data-confirm-index="${index}"
                    data-confirm-action="yes"
                  >
                    Sim
                  </button>
                </div>
              </div>
            </div>`
              : "";
            card.innerHTML = `
            ${removalMarkup}
            <div class="player-placeholder">
              <div class="player-bed">
                <img src="${artSrc}" alt="Jogador dormindo na cama" class="player-bed__art${player.accessory === "bluetiara" ? " is-bluetiara" : ""}" />
                <div class="player-bed__legs">
                  ${bedLegsMarkup}
                </div>
                ${zzMarkup}
              </div>
            </div>
            ${lettersMarkup}
            <div class="player-meta">
                <span class="player-title">${player.name}</span>
                <span class="player-status">
                  ${statusText}
                </span>
              </div>
              ${statsMarkup}
              ${showElimOverlay ? `<div class="player-elim-gif" aria-hidden="true"><div class="elim-text">${player.name} foi eliminado</div></div>` : ""}
            `;
            playerStage.appendChild(card);
          });
          updateInfo();
          renderStartingPlayerMenu();
          updatePlayerModeAvailability();
        }

        function removePlayer(index) {
          if (!gameState.roundOver) {
            setMessage("Não é possível remover um jogador durante a partida.", "error");
            return;
          }
          if (typeof index !== "number" || index < 0 || index >= gameState.players.length) {
            removalCandidateIndex = null;
            return;
          }
          const [removed] = gameState.players.splice(index, 1);
          if (!removed) {
            removalCandidateIndex = null;
            return;
          }
          if (selectedTraitorIndex !== null) {
            if (selectedTraitorIndex === index) {
              selectedTraitorIndex = null;
              selectedLibraryWord = "";
              updateSelectedWordInfo();
            } else if (selectedTraitorIndex > index) {
              selectedTraitorIndex--;
            }
          }
          if (gameState.activeIndex >= gameState.players.length) {
            gameState.activeIndex = Math.max(0, gameState.players.length - 1);
          }
          removalCandidateIndex = null;
          renderPlayers();
          updateStartButtonState();
          updateChangeWordButtonState();
          setMessage(`${removed.name} foi removido do jogo.`, "info");
        }

        function updateInfo() {
          if (!gameState.players.length) {
            turnInfoEl.textContent = "Adicione jogadores para começar.";
            progressInfoEl.textContent = "";
            return;
          }
          const current = gameState.players[gameState.activeIndex];
          turnInfoEl.textContent = `Vez atual: ${current.name}`;
          progressInfoEl.textContent = `Erros: ${current.mistakes}/${MAX_WRONG}`;
        }

        function startRound(forcedWord = "") {
          if (!gameState.players.length) {
            setMessage("Precisa de pelo menos um jogador.", "error");
            return;
          }
          clearWordPreview();
          if (selectionMode === "player" && !selectedLibraryWord && !forcedWord) {
            setMessage("Selecione uma palavra na biblioteca antes de iniciar.", "error");
            return;
          }
          const startingCandidate = ensureStartingPlayerIndex();
          gameState.activeIndex = findNextActivePlayerIndex(startingCandidate - 1);
          gameState.roundOver = false;
          setWordDisplayVisibility(true);
          setControlsShellVisibility(true);
          updateModeLabelVisibility();
          gameState.usedLetters.clear();
          const rawWord =
            forcedWord ||
            (selectionMode === "player" ? selectedLibraryWord : getRandomWord());
          const targetWord = (rawWord || "").toString().toUpperCase();
          if (!targetWord) {
            setMessage("Não foi possível determinar a palavra.", "error");
            gameState.roundOver = true;
            setWordDisplayVisibility(false);
            setControlsShellVisibility(false);
            setMainButtonsVisibility(true);
            setRestartVisibility(false);
            updateStartButtonState();
            syncRoundMusic();
            return;
          }
          gameState.currentWord = targetWord;
          if (selectionMode === "player") {
            isSelectedWordRevealed = false;
            selectedLibraryWord = "";
            renderLibraryList(librarySearch.value);
            resetRandomWord();
            updateSelectedWordInfo();
          } else {
            updateSelectedWordInfo();
          }
          gameState.revealed = Array(gameState.currentWord.length).fill(false);
          gameState.players.forEach(player => {
            player.mistakes = 0;
            player.eliminated = false;
            player.guessedLetters = [];
            player.maxBedLegs = bedLegSetting;
            player.bedLegs = player.maxBedLegs;
            player.scared = false;
          });
          createWordTiles();
          updateKeyboard();
          setMessage(`${gameState.players[gameState.activeIndex].name} começa a rodada.`, "info");
          setLetterResult("");
          updateStartButtonState();
          renderPlayers();
          updateChangeWordButtonState();
          syncRoundMusic();
          setVolumeVisibility(false);
          setMainButtonsVisibility(false);
          setRestartVisibility(true);
          if (traitorCallout) {
            traitorCallout.classList.remove("is-visible");
            traitorCallout.setAttribute("aria-hidden", "true");
          }
          if (selectionMode === "player" && selectedTraitorIndex !== null) {
            const traitor = gameState.players[selectedTraitorIndex];
            if (traitor) {
              showTraitorCallout(`${traitor.name} é o traidor`);
            }
          }
        }

        function endRound(won) {
          gameState.roundOver = true;
          updateModeLabelVisibility();
          updateStartButtonState();
          updateKeyboard();
          let winnerName = null;
          let traitorWinnerName = null;
          if (won) {
            const winner = gameState.players[gameState.activeIndex];
            winner.victories++;
            winnerName = winner.name;
            setMessage(`${winner.name} acertou a palavra ${gameState.currentWord}!`, "success");
            if (!letterResultEl.textContent) {
              setLetterResult(`${winner.name} venceu!`, "success");
            }
          } else {
            const traitor = selectedTraitorIndex !== null ? gameState.players[selectedTraitorIndex] : null;
            if (traitor) {
              traitor.victories++;
              traitorWinnerName = traitor.name;
              setMessage(
                `A palavra era ${gameState.currentWord}. ${traitor.name} venceu como traidor!`,
                "success"
              );
              if (!letterResultEl.textContent) {
                setLetterResult(`${traitor.name} traiu todo mundo!`, "info");
              }
            } else {
              setMessage(`A palavra era ${gameState.currentWord}.`, "error");
              if (!letterResultEl.textContent) {
                setLetterResult("Ninguém ganhou.", "error");
              }
          }
        }
        const resultText = traitorWinnerName
            ? `O traidor (${traitorWinnerName}) ganhou!`
            : winnerName
              ? `${winnerName} ganhou!`
              : "Ninguém ganhou";
          if (!winnerName && !traitorWinnerName) {
            const entries = gameState.players
              .map((player, index) => ({ ...player, index }))
              .sort((a, b) => a.mistakes - b.mistakes || a.index - b.index);
            showNoWinnerOverlay(gameState.currentWord, entries);
          } else {
          showFinishOverlay(resultText);
        }
        setVolumeVisibility(true);
        renderPlayers();
        updateChangeWordButtonState();
        if (traitorCallout) {
          traitorCallout.classList.remove("is-visible");
          traitorCallout.setAttribute("aria-hidden", "true");
          }
          unlockControls();
          syncRoundMusic();
          clearWordPreview();
          setWordDisplayVisibility(false);
          setControlsShellVisibility(false);
          setMainButtonsVisibility(true);
          setRestartVisibility(false);
          setLetterResult("");
        }

        function createWordTiles() {
          wordDisplay.innerHTML = "";
          if (!gameState.currentWord) {
            return;
          }
          gameState.currentWord.split("").forEach((letter, index) => {
            const tile = document.createElement("span");
            tile.className = "word-tile";
            if (gameState.revealed[index]) {
              tile.classList.add("is-filled");
              tile.textContent = letter;
            }
            wordDisplay.appendChild(tile);
          });
        }

        function getRandomWord() {
          const index = Math.floor(Math.random() * WORD_POOL.length);
          return WORD_POOL[index];
        }

        function canStartRound() {
          if (!gameState.players.length || !gameState.roundOver) {
            return false;
          }
          if (selectionMode === "player") {
            return !!selectedLibraryWord;
          }
          return true;
        }

        function updateStartButtonState() {
          const ready = canStartRound();
          startGameBtn.disabled = !ready;
        }

        function updateModeLabelVisibility() {
          if (!modeLabelEl) {
            return;
          }
          modeLabelEl.hidden = !gameState.roundOver;
        }

        function setMessage(text, tone = "info") {
          messageEl.textContent = text;
          messageEl.dataset.tone = tone;
        }

        function setLetterResult(text = "", tone = "info") {
          letterResultEl.textContent = text;
          if (text) {
            letterResultEl.dataset.tone = tone;
            letterResultEl.classList.add("is-visible");
          } else {
            letterResultEl.removeAttribute("data-tone");
            letterResultEl.classList.remove("is-visible");
          }
        }

        function setReviewFeedback(text = "", tone = "info") {
          if (!reviewFeedbackEl) {
            return;
          }
          reviewFeedbackEl.textContent = text;
          reviewFeedbackEl.dataset.tone = tone;
          reviewFeedbackEl.hidden = !text;
        }

        function cancelReviewInfoHideTimer() {
          if (reviewInfoHideTimer) {
            clearTimeout(reviewInfoHideTimer);
            reviewInfoHideTimer = null;
          }
        }

        function scheduleReviewInfoHide(delay = 160) {
          cancelReviewInfoHideTimer();
          reviewInfoHideTimer = setTimeout(() => {
            reviewInfoHideTimer = null;
            toggleReviewInfoPopover(false);
          }, delay);
        }

        function showReviewInfoPopover() {
          cancelReviewInfoHideTimer();
          toggleReviewInfoPopover(true);
        }

        function hideReviewInfoPopover() {
          cancelReviewInfoHideTimer();
          toggleReviewInfoPopover(false);
        }

        function toggleReviewInfoPopover(show) {
          if (!reviewInfoBtn || !reviewInfoPopover) {
            return;
          }
          const isOpen = Boolean(show);
          reviewInfoPopover.setAttribute("aria-hidden", isOpen ? "false" : "true");
          reviewInfoPopover.classList.toggle("is-visible", isOpen);
          reviewInfoBtn.setAttribute("aria-expanded", isOpen ? "true" : "false");
        }

        function setAdminFeedback(text = "", tone = "info") {
          if (!reviewsAdminFeedback) {
            return;
          }
          reviewsAdminFeedback.textContent = text;
          reviewsAdminFeedback.dataset.tone = tone;
          reviewsAdminFeedback.hidden = !text;
        }

        function setZoom(value = 1) {
          const clamped = Math.max(0.7, Math.min(1.3, Number(value) || 1));
          appZoom = clamped;
          document.documentElement.style.setProperty("--app-zoom", String(clamped));
          if (zoomValueEl) {
            zoomValueEl.textContent = `${Math.round(clamped * 100)}%`;
          }
          try {
            localStorage.setItem(ZOOM_STORAGE_KEY, String(clamped));
          } catch (error) {
            /* ignore */
          }
        }

        function applyStoredZoom() {
          try {
            const stored = parseFloat(localStorage.getItem(ZOOM_STORAGE_KEY) || "");
            if (!Number.isNaN(stored)) {
              setZoom(stored);
              return;
            }
          } catch (error) {
            /* ignore */
          }
          setZoom(1);
        }

        function updateNameCounter() {
          if (!reviewNameCounter || !reviewNameInput) {
            return;
          }
          const len = (reviewNameInput.value || "").length;
          reviewNameCounter.textContent = `${len}/40`;
        }

        function updateTextCounter() {
          if (!reviewTextCounter || !reviewTextInput) {
            return;
          }
          const len = (reviewTextInput.value || "").length;
          reviewTextCounter.textContent = `${len}/400`;
        }

        function setReviewRating(value = 0) {
          const safe = Math.floor(value);
          currentReviewRating = safe >= 1 && safe <= 5 ? safe : 0;
          reviewStarsButtons.forEach(button => {
            const val = parseInt(button.dataset.rating || "0", 10);
            const active = currentReviewRating > 0 && val <= currentReviewRating;
            button.classList.toggle("is-active", active);
            button.setAttribute("aria-pressed", String(active));
          });
        }

        function setReviewHover(value = 0) {
          const safe = Math.floor(value);
          reviewStarsButtons.forEach(button => {
            const val = parseInt(button.dataset.rating || "0", 10);
            const hover = safe > 0 && val <= safe;
            button.classList.toggle("is-hover", hover);
          });
        }

        function updateReviewSummary() {
          if (!reviewsSummaryEl) {
            return;
          }
          const total = reviews.length;
          const rated = reviews.filter(entry => entry.rating && entry.rating > 0);
          const avg =
            rated.length > 0
              ? rated.reduce((sum, entry) => sum + (entry.rating || 0), 0) / rated.length
              : 0;
          const avgText = rated.length ? `${avg.toFixed(1)}★` : "Sem notas";
          reviewsSummaryEl.textContent = `${avgText} · ${total} avaliação${total === 1 ? "" : "es"}`;
        }

        function updateReviewCategories() {
          if (!reviewCategoriesEl) {
            return;
          }
          const grouped = { 1: [], 2: [], 3: [], 4: [], 5: [] };
          reviews.forEach(entry => {
            const r = entry.rating ? Math.min(5, Math.max(1, Math.round(entry.rating))) : 0;
            if (r >= 1 && r <= 5) {
              grouped[r].push(entry);
            }
          });

          Object.entries(reviewCountByStar).forEach(([key, el]) => {
            if (!el) return;
            const star = parseInt(key, 10);
            const list = grouped[star] || [];
            el.textContent = list.length;
          });

          const critical = [...grouped[1], ...grouped[2]];
          const positive = [...grouped[4], ...grouped[5]];
          const neutral = grouped[3] || [];

          if (reviewCountCritical) {
            reviewCountCritical.textContent = critical.length;
          }
          if (reviewCountPositive) {
            reviewCountPositive.textContent = positive.length;
          }
          if (reviewCountThree) {
            reviewCountThree.textContent = neutral.length;
          }

          reviewCategoryButtons.forEach(button => {
            const filter = button.dataset.filter || "";
            button.classList.toggle("is-active", filter === activeReviewFilter);
          });
        }

        function applyReviewFilter(entries) {
          if (activeReviewFilter === "all") {
            return entries;
          }
          if (activeReviewFilter.startsWith("star-")) {
            const star = parseInt(activeReviewFilter.split("-")[1], 10);
            return entries.filter(entry => entry.rating === star);
          }
          if (activeReviewFilter === "positive") {
            return entries.filter(entry => entry.rating && entry.rating >= 4);
          }
          if (activeReviewFilter === "neutral") {
            return entries.filter(entry => entry.rating === 3);
          }
          if (activeReviewFilter === "critical") {
            return entries.filter(entry => entry.rating && entry.rating <= 2);
          }
          return entries;
        }

        async function syncReviews() {
          const latest = await loadReviewsFromStorage();
          reviews = latest;
          if (reviewsEmptyState) {
            reviewsEmptyState.hidden = !!reviews.length;
          }
          updateReviewButtonLabel();
          renderReviewList();
          updateReviewSummary();
          updateReviewCategories();
          updateNameCounter();
          updateTextCounter();
        }

        function startReviewsSyncTimer() {
          clearReviewsSyncTimer();
          reviewsSyncTimer = setInterval(() => {
            syncReviews();
          }, 4000);
        }

        function clearReviewsSyncTimer() {
          if (reviewsSyncTimer) {
            clearInterval(reviewsSyncTimer);
            reviewsSyncTimer = null;
          }
        }

        function setupReviewsRealtime() {
          if (!supabaseClient || reviewsChannel) {
            return;
          }
          reviewsChannel = supabaseClient
            .channel("reviews-realtime")
            .on(
              "postgres_changes",
              { event: "*", schema: "public", table: "reviews" },
              () => {
                syncReviews();
              }
            )
            .subscribe(status => {
              if (status === "SUBSCRIBED") {
                /* ok */
              }
            });
        }

        function runPanelAnimation(panel, closing = false) {
          if (!panel) return;
          panel.classList.remove("panel-animate-open", "panel-animate-close");
          void panel.offsetWidth;
          panel.classList.add(closing ? "panel-animate-close" : "panel-animate-open");
          const clearClass = closing ? "panel-animate-close" : "panel-animate-open";
          setTimeout(() => {
            panel.classList.remove(clearClass);
          }, closing ? 220 : 320);
        }

        function hexToRgba(hex = "", alpha = 1) {
          const value = hex.replace("#", "");
          const bigint = parseInt(value.length === 3 ? value.repeat(2) : value, 16);
          const r = (bigint >> 16) & 255;
          const g = (bigint >> 8) & 255;
          const b = bigint & 255;
          return `rgba(${r}, ${g}, ${b}, ${Math.max(0, Math.min(1, alpha))})`;
        }

        function updateThemeVars(theme) {
          const target = theme || THEME_OPTIONS[themeIndex] || THEME_OPTIONS[0];
          const border = hexToRgba(target.color, 0.8);
          const bgWeak = hexToRgba(target.color, 0.16);
          document.documentElement.style.setProperty("--accent", target.color);
          document.documentElement.style.setProperty("--vivid", target.color);
          document.documentElement.style.setProperty("--btn-solid-text", target.text || "#0b0f1b");
          document.documentElement.style.setProperty("--theme-border", border);
          document.documentElement.style.setProperty("--theme-bg-weak", bgWeak);
        }

        function animateCircle(theme, direction = 1) {
          if (!colorCircle || !theme) {
            return;
          }
          const exitClass = direction > 0 ? "is-exit-right" : "is-exit-left";
          const enterClass = direction > 0 ? "is-enter-left" : "is-enter-right";
          colorCircle.classList.remove("is-enter-left", "is-enter-right", "is-exit-left", "is-exit-right");
          colorCircle.classList.add(exitClass);
          setTimeout(() => {
            colorCircle.style.background = theme.color;
            colorCircle.style.borderColor = hexToRgba(theme.color, 0.6);
            colorCircle.classList.remove(exitClass);
            colorCircle.classList.add(enterClass);
            requestAnimationFrame(() => {
              requestAnimationFrame(() => {
                colorCircle.classList.remove(enterClass);
              });
            });
          }, 140);
          if (colorLabel) {
            colorLabel.textContent = theme.name;
          }
        }

        function setThemeByIndex(nextIndex, direction = 1) {
          if (!THEME_OPTIONS.length) {
            return;
          }
          const total = THEME_OPTIONS.length;
          themeIndex = ((nextIndex % total) + total) % total;
          const theme = THEME_OPTIONS[themeIndex];
          updateThemeVars(theme);
          animateCircle(theme, direction);
          try {
            localStorage.setItem("forca-theme-index", String(themeIndex));
          } catch (error) {
            /* ignore */
          }
        }

        function ensureUserId() {
          try {
            const stored = localStorage.getItem(REVIEW_OWNER_KEY);
            if (stored) {
              currentUserId = stored;
              return currentUserId;
            }
          } catch (error) {
            console.warn("Nao foi possivel acessar o armazenamento de usuario.", error);
          }
          const fresh = generateReviewId("usr");
          currentUserId = fresh;
          try {
            localStorage.setItem(REVIEW_OWNER_KEY, fresh);
          } catch (error) {
            console.warn("Nao foi possivel guardar o identificador do usuario.", error);
          }
          return currentUserId;
        }

        function getUserReview() {
          return reviews.find(entry => entry.ownerId === currentUserId) || null;
        }

        function updateReviewFormVisibility() {
          if (!reviewForm) {
            return;
          }
          const hasOwnReview = !!getUserReview();
          const shouldShow = editingReviewId !== null || !hasOwnReview;
          reviewForm.hidden = !shouldShow;
        }

        function generateReviewId(prefix = "") {
          const uuid =
            typeof crypto !== "undefined" && typeof crypto.randomUUID === "function"
              ? crypto.randomUUID()
              : (() => {
                  const hex = () => Math.floor((1 + Math.random()) * 0x10000).toString(16).slice(1);
                  return `${hex()}${hex()}-${hex()}-${hex()}-${hex()}-${hex()}${hex()}${hex()}`;
                })();
          return prefix ? `${prefix}-${uuid}` : uuid;
        }

        function generateAnonName() {
          const suffix = Math.floor(1000 + Math.random() * 9000);
          return `Anonimo#${suffix}`;
        }

        function getStableAnonName(seed = "") {
          const base = (seed || "").toString();
          if (!base) {
            return generateAnonName();
          }
          let hash = 0;
          for (let i = 0; i < base.length; i++) {
            hash = (hash * 31 + base.charCodeAt(i)) >>> 0;
          }
          const suffix = String(hash % 10000).padStart(4, "0");
          return `Anonimo#${suffix}`;
        }

        function normalizeReviewName(value = "") {
          return value
            .trim()
            .replace(/\s+/g, " ")
            .toUpperCase()
            .normalize("NFD")
            .replace(/[\u0300-\u036f]/g, "")
            .normalize("NFC");
        }

        function isReviewNameTaken(name = "", ignoreOwnerId = currentUserId) {
          const normalized = normalizeReviewName(name);
          if (!normalized) {
            return false;
          }
          return reviews.some(
            entry => entry.ownerId !== ignoreOwnerId && normalizeReviewName(entry.author) === normalized
          );
        }

        function buildReviewNameSuggestions(baseName = "", count = 2) {
          const base = (baseName || "").trim() || "Jogador";
          const cleanBase = base.replace(/\s+/g, " ");
          const used = new Set(reviews.map(entry => normalizeReviewName(entry.author)));
          const suggestions = [];
          let suffix = 1;
          while (suggestions.length < count && suffix < 50) {
            const candidate = `${cleanBase} ${suffix}`;
            if (!used.has(normalizeReviewName(candidate))) {
              suggestions.push(candidate);
              used.add(normalizeReviewName(candidate));
            }
            suffix += 1;
          }
          while (suggestions.length < count) {
            const candidate = `${cleanBase} ${Math.floor(10 + Math.random() * 90)}`;
            if (!used.has(normalizeReviewName(candidate))) {
              suggestions.push(candidate);
              used.add(normalizeReviewName(candidate));
            }
          }
          return suggestions;
        }

        function escapeHtml(value = "") {
          return value
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/"/g, "&quot;")
            .replace(/'/g, "&#39;");
        }

        function formatReviewDate(timestamp) {
          if (!timestamp) {
            return "";
          }
          try {
            return new Intl.DateTimeFormat("pt-BR", { dateStyle: "short", timeStyle: "short" }).format(
              new Date(timestamp)
            );
          } catch (error) {
            return new Date(timestamp).toLocaleString();
          }
        }

        async function loadReviewsFromStorage() {
          const fallback = [];
          if (!supabaseClient) {
            console.warn("Supabase indisponivel; sem avaliações remotas.");
            return fallback;
          }
          try {
            const { data, error } = await supabaseClient
              .from("reviews")
              .select("*")
              .order("created_at", { ascending: false });
            if (error) {
              throw error;
            }
            return (data || [])
              .map(entry => ({
                id: typeof entry.id === "string" ? entry.id : generateReviewId(),
                author:
                  typeof entry.author === "string" && entry.author.trim()
                    ? entry.author.trim()
                    : getStableAnonName(entry.owner_id || entry.id || entry.created_at || "anon"),
                text: typeof entry.text === "string" ? entry.text.trim().slice(0, 280) : "",
                likes: Number.isFinite(entry.likes) ? Math.max(0, entry.likes) : 0,
                dislikes: Number.isFinite(entry.dislikes) ? Math.max(0, entry.dislikes) : 0,
                createdAt: entry.created_at ? new Date(entry.created_at).getTime() : Date.now(),
                editedAt: entry.edited_at ? new Date(entry.edited_at).getTime() : null,
                ownerId: typeof entry.owner_id === "string" ? entry.owner_id : "",
                rating: Number.isFinite(entry.rating) ? Math.min(5, Math.max(1, Math.round(entry.rating))) : 0
              }))
              .filter(entry => entry.text);
          } catch (error) {
            console.warn("Nao foi possivel ler as avaliações remotas.", error);
            return fallback;
          }
        }

        async function saveReviewRemote(entry) {
          if (!supabaseClient) {
            console.warn("Supabase indisponivel; não foi possivel salvar a avaliação.");
            return;
          }
          try {
            const safeAuthor =
              entry.author && entry.author.trim()
                ? entry.author.trim()
                : getStableAnonName(entry.ownerId || entry.id || entry.createdAt || "anon");
            const payload = {
              id: entry.id || generateReviewId(),
              owner_id: entry.ownerId || "",
              author: safeAuthor,
              text: entry.text || "",
              likes: Number.isFinite(entry.likes) ? entry.likes : 0,
              dislikes: Number.isFinite(entry.dislikes) ? entry.dislikes : 0,
              rating: Number.isFinite(entry.rating) ? Math.min(5, Math.max(1, Math.round(entry.rating))) : null,
              created_at: entry.createdAt
                ? new Date(entry.createdAt).toISOString()
                : new Date().toISOString(),
              edited_at: entry.editedAt ? new Date(entry.editedAt).toISOString() : null
            };
            const { data, error } = await supabaseClient.from("reviews").upsert(payload).select().single();
            if (error) {
              throw error;
            }
            if (data?.id) {
              entry.id = data.id;
            }
            entry.author = safeAuthor;
          } catch (error) {
            console.warn("Nao foi possivel salvar a avaliação remota.", error);
          }
        }

        function loadReviewVotes() {
          try {
            const raw = localStorage.getItem(REVIEW_VOTES_KEY);
            if (!raw) {
              return {};
            }
            const parsed = JSON.parse(raw);
            if (!parsed || typeof parsed !== "object") {
              return {};
            }
            return parsed;
          } catch (error) {
            console.warn("Nao foi possivel ler os votos de avaliações.", error);
            return {};
          }
        }

        function saveReviewVotes(map) {
          try {
            localStorage.setItem(REVIEW_VOTES_KEY, JSON.stringify(map));
          } catch (error) {
            console.warn("Nao foi possivel salvar os votos.", error);
          }
        }

        function updateReviewButtonLabel() {
          if (reviewsBtn) {
            reviewsBtn.textContent = `Avaliações (${reviews.length})`;
          }
        }

        function renderReviewList() {
          if (!reviewsList) {
            updateReviewButtonLabel();
            return;
          }
          const entries = applyReviewFilter([...reviews]).sort((a, b) => b.createdAt - a.createdAt);
          if (!entries.length) {
            reviewsList.innerHTML = "";
            if (reviewsEmptyState) {
              reviewsEmptyState.hidden = false;
            }
            updateReviewButtonLabel();
            return;
          }
          const renderEntry = entry => {
            const vote = reviewVotes[entry.id];
            const likeActive = vote === "up";
            const dislikeActive = vote === "down";
          const metaText = entry.editedAt ? `Editada, ${formatReviewDate(entry.editedAt)}` : formatReviewDate(entry.createdAt);
          const isOwner = entry.ownerId && entry.ownerId === currentUserId;
          let ownerActions = "";
          if (isOwner) {
            ownerActions = `<div class="review-owner-actions">
                  <button class="ghost-btn tiny review-action" type="button" data-action="edit" aria-label="Editar avaliação">Editar</button>
                  <button class="ghost-btn tiny review-action" type="button" data-action="delete" aria-label="Excluir avaliação">Excluir</button>
                </div>`;
          } else if (isAdminUnlocked) {
            ownerActions = `<div class="review-owner-actions">
                  <button class="ghost-btn tiny review-action" type="button" data-action="delete" aria-label="Excluir avaliação (admin)">Excluir</button>
                </div>`;
          }
          const chip = isOwner ? '<span class="review-chip">Sua avaliação</span>' : "";
          const ratingStars =
            entry.rating && entry.rating > 0
              ? '<span class="review-rating-display">' +
                Array.from({ length: entry.rating }, () => "★").join("") +
                Array.from({ length: 5 - entry.rating }, () => "☆").join("") +
                "</span>"
              : "";
          return `<article class="review-item${isOwner ? " is-mine" : ""}" data-id="${entry.id}">
              <header class="review-item__header">
                <span class="review-item__author">${escapeHtml(entry.author)} ${ratingStars}</span>
                <div style="display:flex; align-items:center; gap:0.5rem; flex-wrap: wrap; justify-content: flex-end;">
                  ${chip}
                  <span class="review-item__meta">${metaText}</span>
                  ${ownerActions}
                </div>
              </header>
              <p class="review-item__text">${escapeHtml(entry.text)}</p>
              <div class="review-item__actions">
                <button class="review-vote${likeActive ? " is-active" : ""}" type="button" data-vote="up" aria-pressed="${likeActive}">
                  <span class="vote-icon" aria-hidden="true">👍</span>
                  <span class="vote-label">Like</span>
                  <span class="vote-count">${entry.likes}</span>
                </button>
                <button class="review-vote${dislikeActive ? " is-active" : ""}" type="button" data-vote="down" aria-pressed="${dislikeActive}">
                  <span class="vote-icon" aria-hidden="true">👎</span>
                  <span class="vote-label">Deslike</span>
                  <span class="vote-count">${entry.dislikes}</span>
                </button>
              </div>
            </article>`;
          };

          const mine = entries.filter(entry => entry.ownerId === currentUserId);
          const others = entries.filter(entry => entry.ownerId !== currentUserId);
          const pieces = [];
          if (mine.length) {
            mine.forEach(entry => pieces.push(renderEntry(entry)));
            if (others.length) {
              pieces.push('<div class="review-divider" aria-hidden="true"></div>');
            }
          }
          others.forEach(entry => pieces.push(renderEntry(entry)));
          reviewsList.innerHTML = pieces.join("");
          if (reviewsEmptyState) {
            reviewsEmptyState.hidden = true;
          }
          updateReviewButtonLabel();
        }

        function openReviewsOverlay() {
          if (!reviewsOverlay) {
            return;
          }
          updateReviewFormVisibility();
          syncReviews();
          startReviewsSyncTimer();
          reviewsOverlay.classList.add("is-open");
          reviewsOverlay.setAttribute("aria-hidden", "false");
          reviewsBtn?.classList.add("is-active");
          setReviewFeedback("");
          setReviewRating(0);
          updateNameCounter();
          updateTextCounter();
          hideReviewInfoPopover();
        }

        function closeReviewsOverlay() {
          if (!reviewsOverlay) {
            return;
          }
          clearReviewsSyncTimer();
          reviewsOverlay.classList.remove("is-open");
          reviewsOverlay.setAttribute("aria-hidden", "true");
          reviewsBtn?.classList.remove("is-active");
          hideReviewInfoPopover();
        }

        function normalizeReviewTextForFilter(text = "") {
          return text
            .split("")
            .map(char => {
              const mapped = LEET_SUBSTITUTIONS[char];
              return mapped ? mapped : char;
            })
            .join("")
            .toLowerCase();
        }

        function findOffensiveReviewTerm(text = "") {
          if (!OFFENSIVE_REVIEW_TERMS.length) {
            return null;
          }
          const normalized = normalizeReviewTextForFilter(text);
          for (const term of OFFENSIVE_REVIEW_TERMS) {
            const candidate = (term || "").trim().toLowerCase();
            if (!candidate) {
              continue;
            }
            if (normalized.includes(candidate)) {
              return candidate;
            }
          }
          return null;
        }

        async function handleReviewSubmit(event) {
          event.preventDefault();
          if (!currentUserId) {
            ensureUserId();
          }
          const text = (reviewTextInput?.value || "").trim();
          const name = (reviewNameInput?.value || "").trim();
          const rating = currentReviewRating;
          if (!text) {
            setReviewFeedback("Escreva sua avaliação para enviar.", "error");
            reviewTextInput?.focus();
            return;
          }
          if (text.length > 400) {
            setReviewFeedback("Limite de 400 caracteres.", "error");
            reviewTextInput?.focus();
            return;
          }
          const offensiveTerm = findOffensiveReviewTerm(text);
          if (offensiveTerm) {
            setReviewFeedback(`Avaliação bloqueada. Detectamos o termo "${offensiveTerm}".`, "error");
            reviewTextInput?.focus();
            return;
          }
          if (!rating) {
            setReviewFeedback("Escolha de 1 a 5 estrelas.", "error");
            reviewStarsButtons[0]?.focus();
            return;
          }
          if (name && isReviewNameTaken(name, currentUserId)) {
            const [firstSuggestion = `${name} 1`, secondSuggestion = `${name} 2`] = buildReviewNameSuggestions(
              name,
              2
            );
            const suggestionText =
              firstSuggestion && secondSuggestion
                ? `${firstSuggestion} ou ${secondSuggestion}`
                : firstSuggestion || secondSuggestion || "outro nome";
            setReviewFeedback(`Nome usado. Tente ${suggestionText}.`, "error");
            reviewNameInput?.focus();
            reviewNameInput?.select?.();
            return;
          }
          if (editingReviewId) {
            const entry = reviews.find(item => item.id === editingReviewId);
            if (entry && entry.ownerId === currentUserId) {
              entry.author = name || entry.author || generateAnonName();
              entry.text = text.slice(0, 280);
              entry.rating = rating;
              entry.editedAt = Date.now();
              await saveReviewRemote(entry);
              await syncReviews();
              setReviewFeedback(`Avaliação atualizada. Editada, ${formatReviewDate(entry.editedAt)}.`, "success");
            } else {
              setReviewFeedback("Nao foi possivel editar esta avaliação.", "error");
            }
            clearEditingState();
          } else {
            const existing = reviews.find(item => item.ownerId === currentUserId);
            if (existing) {
              existing.author = name || existing.author || generateAnonName();
              existing.text = text.slice(0, 280);
              existing.rating = rating;
              existing.editedAt = Date.now();
              await saveReviewRemote(existing);
              await syncReviews();
              setReviewFeedback(`Sua avaliação foi atualizada. Editada, ${formatReviewDate(existing.editedAt)}.`, "success");
            } else {
              const entry = {
                id: generateReviewId(),
                ownerId: currentUserId,
                author: name || generateAnonName(),
                text: text.slice(0, 280),
                likes: 0,
                dislikes: 0,
                rating,
                createdAt: Date.now(),
                editedAt: null
              };
              reviews.unshift(entry);
              await saveReviewRemote(entry);
              await syncReviews();
              setReviewFeedback("Avaliação enviada! Obrigado pelo retorno.", "success");
              if (reviewsEmptyState) {
                reviewsEmptyState.hidden = true;
              }
            }
          }
          if (reviewTextInput) {
            reviewTextInput.value = "";
          }
          setReviewRating(0);
          updateReviewFormVisibility();
        }

        async function handleReviewVote(reviewId, direction) {
          const entry = reviews.find(item => item.id === reviewId);
          if (!entry || (direction !== "up" && direction !== "down")) {
            return;
          }
          const previous = reviewVotes[reviewId];
          if (previous === "up") {
            entry.likes = Math.max(0, entry.likes - 1);
          } else if (previous === "down") {
            entry.dislikes = Math.max(0, entry.dislikes - 1);
          }
          if (previous === direction) {
            delete reviewVotes[reviewId];
          } else {
            if (direction === "up") {
              entry.likes += 1;
            } else {
              entry.dislikes += 1;
            }
            reviewVotes[reviewId] = direction;
          }
          saveReviewVotes(reviewVotes);
          await saveReviewRemote(entry);
          await syncReviews();
        }

        function startEditingReview(reviewId) {
          const entry = reviews.find(item => item.id === reviewId);
          if (!entry || entry.ownerId !== currentUserId) {
            setReviewFeedback("Você só pode editar a sua avaliação.", "error");
            return;
          }
          editingReviewId = reviewId;
          updateReviewFormVisibility();
          if (reviewNameInput) {
            reviewNameInput.value = entry.author.startsWith("Anonimo#") ? "" : entry.author;
          }
          if (reviewTextInput) {
            reviewTextInput.value = entry.text;
            reviewTextInput.focus();
          }
          setReviewRating(entry.rating || 0);
          updateNameCounter();
          updateTextCounter();
          if (reviewSubmitBtn) {
            reviewSubmitBtn.textContent = "Salvar edicao";
          }
          if (reviewCancelEditBtn) {
            reviewCancelEditBtn.hidden = false;
          }
          setReviewFeedback("Editando sua avaliação.", "info");
        }

        function clearEditingState() {
          editingReviewId = null;
          if (reviewSubmitBtn) {
            reviewSubmitBtn.textContent = "Publicar";
          }
          if (reviewCancelEditBtn) {
            reviewCancelEditBtn.hidden = true;
          }
          if (reviewNameInput) {
            reviewNameInput.value = "";
          }
          if (reviewTextInput) {
            reviewTextInput.value = "";
          }
          setReviewRating(0);
          updateNameCounter();
          updateTextCounter();
          updateReviewFormVisibility();
        }

        async function deleteReview(reviewId) {
          const entry = reviews.find(item => item.id === reviewId);
          if (!entry || (entry.ownerId !== currentUserId && !isAdminUnlocked)) {
            setReviewFeedback("Voce so pode excluir a sua avaliação.", "error");
            return;
          }
          if (supabaseClient) {
            try {
              const { error } = await supabaseClient.from("reviews").delete().eq("id", reviewId);
              if (error) {
                throw error;
              }
            } catch (error) {
              console.warn("Nao foi possivel remover a avaliação remota.", error);
              setReviewFeedback("Falha ao excluir. Verifique as permissões no Supabase.", "error");
              return;
            }
          }
          reviews = reviews.filter(item => item.id !== reviewId);
          delete reviewVotes[reviewId];
          saveReviewVotes(reviewVotes);
          await syncReviews();
          clearEditingState();
          setReviewFeedback("Avaliação removida.", "success");
          if (!reviews.length && reviewsEmptyState) {
            reviewsEmptyState.hidden = false;
          }
          updateReviewFormVisibility();
        }

        async function initializeReviews() {
          ensureUserId();
          reviews = await loadReviewsFromStorage();
          reviewVotes = loadReviewVotes();
          setupReviewsRealtime();
          if (reviewsEmptyState) {
            reviewsEmptyState.hidden = !!reviews.length;
          }
          updateReviewButtonLabel();
          renderReviewList();
          updateReviewSummary();
          updateReviewCategories();
          setReviewFeedback("");
          updateReviewFormVisibility();
          updateNameCounter();
          updateTextCounter();
        }

        function toggleAdminPanel() {
          if (!reviewsAdminPanel || !reviewsAdminToggle) {
            return;
          }
          const isOpen = !reviewsAdminPanel.hidden;
          const next = !isOpen;
          reviewsAdminPanel.hidden = !next;
          reviewsAdminToggle.setAttribute("aria-expanded", String(next));
          if (next && reviewsAdminInput) {
            reviewsAdminInput.value = "";
            reviewsAdminInput.focus();
          }
          setAdminFeedback("");
        }

        function sanitizeWordInput(value = "") {
          return value
            .toUpperCase()
            .normalize("NFD")
            .replace(/[^A-Z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF]/g, "")
            .normalize("NFC");
        }

        function normalizeCharForMatch(char = "") {
          return char
            .toUpperCase()
            .normalize("NFD")
            .replace(/[\u0300-\u036f]/g, "")
            .replace(/Ç/g, "C")
            .normalize("NFC");
        }

        function normalizeForMatch(text = "") {
          return text
            .split("")
            .map(normalizeCharForMatch)
            .join("");
        }

        function updateModeButtons() {
          modeButtons.forEach(button => {
            button.classList.toggle("is-active", button.dataset.mode === selectionMode);
          });
        }

        function renderLibraryList(query = "") {
          if (!libraryList) {
            return;
          }
          const term = sanitizeWordInput(query);
          const termNorm = normalizeForMatch(term);
          const filtered = termNorm
            ? WORD_POOL.filter(word => normalizeForMatch(word).includes(termNorm))
            : [...WORD_POOL];
          const entries = term ? filtered.slice(0, LIBRARY_PAGE_LIMIT) : getRandomSubset(filtered, LIBRARY_PAGE_LIMIT);
          if (!entries.length) {
            libraryList.innerHTML =
              '<p style="color: rgba(255,255,255,0.6); margin:0;">Nenhuma palavra encontrada.</p>';
            return;
          }
          libraryList.innerHTML = entries
            .map(word => `<button type="button" class="library-word" data-word="${word}">${word}</button>`)
            .join("");
        }

        function resetRandomWord() {
          randomLibraryWord = "";
          if (libraryRandomWordEl) {
            libraryRandomWordEl.textContent = "";
          }
          if (libraryRandomConfirmBtn) {
            libraryRandomConfirmBtn.disabled = true;
          }
        }

        function updateChangeWordButtonState() {
          if (!changeWordBtn) {
            return;
          }
          const shouldShow =
            selectionMode === "player" &&
            selectedTraitorIndex !== null &&
            !!selectedLibraryWord &&
            gameState.roundOver &&
            !awaitingLibrarySelection;
          changeWordBtn.hidden = !shouldShow;
        }

        function updatePlayerModeAvailability() {
          if (!playerModeBtn) {
            return;
          }
          const hasMinimumPlayers = gameState.players.length >= 2;
          playerModeBtn.disabled = !hasMinimumPlayers;
          playerModeBtn.hidden = false;
          playerModeBtn.style.display = "";
          if (!hasMinimumPlayers && selectionMode === "player") {
            selectionMode = "random";
            isSelectedWordRevealed = false;
            selectedLibraryWord = "";
            clearWordPreview();
            setWordDisplayVisibility(false);
            updateModeButtons();
            updateStartButtonState();
            updateModeLabelVisibility();
            updateSelectedWordInfo();
            updateChangeWordButtonState();
            setRevealButtonsVisible(false);
            setMessage("Modo Jogador escolhe exige pelo menos 2 jogadores. Voltando para Aleat?rio.", "info");
          }
        }

        function formatHiddenWord(word = "") {
          if (!word) {
            return "";
          }
          return Array.from({ length: word.length }, () => "•").join(" ");
        }

        function syncRevealIcons(revealed) {
          const buttons = [selectedWordRevealBtn, startPlayerRevealBtn].filter(Boolean);
          buttons.forEach(button => {
            const icon = button.querySelector(".eye-icon");
            if (icon) {
              icon.dataset.eyeState = revealed ? "visible" : "hidden";
            }
          });
        }

        function setRevealButtonsVisible(visible) {
          const buttons = [selectedWordRevealBtn, startPlayerRevealBtn].filter(Boolean);
          buttons.forEach(button => {
            button.hidden = !visible;
            button.style.display = visible ? "" : "none";
          });
        }

        function updateSelectedWordInfo() {
          if (!selectedWordInfoEl || !selectedWordLabelEl || !selectedWordDisplayEl || !selectedWordRevealBtn) {
            return;
          }
          const shouldShow = selectionMode === "player" && !!selectedLibraryWord;
          selectedWordInfoEl.hidden = !shouldShow;
          if (!shouldShow) {
            selectedWordLabelEl.textContent = "";
            selectedWordDisplayEl.textContent = "";
            selectedWordRevealBtn.hidden = true;
            if (startPlayerRevealBtn) {
              startPlayerRevealBtn.hidden = true;
            }
            isSelectedWordRevealed = false;
            syncRevealIcons(false);
            setRevealButtonsVisible(false);
            if (gameState.roundOver) {
              clearWordPreview();
            }
            return;
          }

          selectedWordLabelEl.textContent = "Palavra:";
          const text = isSelectedWordRevealed ? selectedLibraryWord : formatHiddenWord(selectedLibraryWord);
          selectedWordDisplayEl.textContent = text;
          selectedWordDisplayEl.classList.toggle("is-hidden", !isSelectedWordRevealed);
          const revealButtons = [selectedWordRevealBtn, startPlayerRevealBtn].filter(Boolean);
          setRevealButtonsVisible(true);
          revealButtons.forEach(button => {
            button.classList.toggle("is-active", isSelectedWordRevealed);
          });
          syncRevealIcons(isSelectedWordRevealed);

          if (isSelectedWordRevealed) {
            renderWordPreview(selectedLibraryWord);
            setWordDisplayVisibility(true, false);
          } else {
            renderMaskedPreview(selectedLibraryWord);
            setWordDisplayVisibility(true, false);
          }
        }

        function getRandomSubset(items, limit) {
          if (items.length <= limit) {
            return items;
          }
          const sample = items.slice();
          for (let i = 0; i < limit; i++) {
            const randIndex = i + Math.floor(Math.random() * (sample.length - i));
            [sample[i], sample[randIndex]] = [sample[randIndex], sample[i]];
          }
          return sample.slice(0, limit);
        }

        function showFinishOverlay(text, { autoClose = true } = {}) {
          if (!finishOverlay || !finishText) {
            return;
          }
          if (finishScoreboard) {
            finishScoreboard.innerHTML = "";
            finishScoreboard.classList.remove("is-visible");
          }
          if (finishCloseLateBtn) {
            finishCloseLateBtn.classList.remove("is-visible");
          }
          clearTimeout(finishCloseRevealTimer);
          finishText.textContent = text;
          finishText.classList.remove("is-animating");
          void finishText.offsetWidth;
          finishText.classList.add("is-animating");
          finishOverlay.classList.add("is-open");
          finishOverlay.setAttribute("aria-hidden", "false");
          clearTimeout(finishOverlayTimer);
          if (autoClose) {
            finishOverlayTimer = setTimeout(() => {
              closeFinishOverlay();
            }, 5200);
          }
        }

        function closeFinishOverlay() {
          if (!finishOverlay || !finishText) {
            return;
          }
          finishText.classList.remove("is-animating");
          finishOverlay.classList.remove("is-open");
          finishOverlay.setAttribute("aria-hidden", "true");
          clearTimeout(finishOverlayTimer);
          clearTimeout(finishCloseRevealTimer);
          if (finishScoreboard) {
            finishScoreboard.innerHTML = "";
            finishScoreboard.classList.remove("is-visible");
          }
          if (finishCloseLateBtn) {
            finishCloseLateBtn.classList.remove("is-visible");
          }
        }

        function renderScoreboard(word, entries) {
          if (!finishScoreboard) {
            return;
          }
          const wordLine = word ? `<p class="finish-scoreboard__word">A palavra era ${word}.</p>` : "";
          const listMarkup = entries
            .map(
              (entry, index) => `<div class="finish-scoreboard__row">
              <span class="finish-scoreboard__rank">${index + 1}º</span>
              <span class="finish-scoreboard__name">${entry.name}</span>
              <span class="finish-scoreboard__errors">${entry.mistakes} erro${entry.mistakes === 1 ? "" : "s"}</span>
            </div>`
            )
            .join("");
          finishScoreboard.innerHTML = `${wordLine}<div class="finish-scoreboard__list">${listMarkup}</div>`;
          requestAnimationFrame(() => {
            finishScoreboard.classList.add("is-visible");
          });
        }

        function showNoWinnerOverlay(word, entries) {
          showFinishOverlay("Ninguém ganhou", { autoClose: false });
          const scoreboardDelay = FINISH_TEXT_ANIM_MS;
          setTimeout(() => {
            renderScoreboard(word, entries);
            if (finishCloseLateBtn) {
              finishCloseLateBtn.classList.remove("is-visible");
              clearTimeout(finishCloseRevealTimer);
              finishCloseRevealTimer = setTimeout(() => {
                finishCloseLateBtn.classList.add("is-visible");
              }, 1000);
            }
          }, scoreboardDelay);
        }
      })();
    </script>
  </body>
</html>

